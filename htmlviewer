#!/usr/bin/env bash

set -e

inputs='# default input.conf
space pgdown_or_next
shift+space pgup_or_prev

z next -5
x next 5
a next -12
s next 12
q next -30
w next 30
e next -100
r next 100

left prev
right next

ctrl+left  next -5
ctrl+right next 5
ctrl+up    next 12
ctrl+down  next -12

| prev
c pgup_or_prev
v prev
b pgup_or_prev
. prev
/ pgdown_or_next

m rotate -90
, rotate 90

h mode webtoon
j mode double
k mode normal

d info
o info

t toggle_auto_scroll
u add_interval -25
i add_interval 25
'

htmlheader='<style>
div,body{margin:0;padding:0;background:#000}
img{display:block;margin:auto;max-width:100%}
#info{padding:.5em;position:absolute;top:0px;color:#000;background:#eee;}
</style>'

config="${XDG_CONFIG_DIRS:-${XDG_DATA_HOME:-$HOME}/.config}"/htmlviewer
inputconf="$config"/input.conf
pixel_distance=20
default_mode=normalMode
startCode=''

usage="Generate a html viewer file

  htmlviewer: [-n] [-s] [-S] [-c <command>] [-e <html>] [-f <filename>]
              [-i <filename>] [-m {normal|webtoon|single|double}] [-t <title>]
              [-x <pixel_distance>] directory...
  htmlviewer: [-p]
  htmlviewer: [-K]

  -c <command>
      Add a command. See input.conf syntax.

  -e <html>
      Specify content of html header. By default its contains the html style.

  -f <filename>
      Read directories from <filename>. If - is specified as filename,
      directories are read from the standard input.

        find -type d | fzf | htmlviewer -f- > view.html

  -i <filename>
      Specify configuration file. See input.conf.

  -h
      Show this help.

  -K
      Generates a html file which displays the name of the keys.

  -m {normal|webtoon|single|double}
      Specify default mode.

  -n
      Do not load default configuration files.

      By default load \${XDG_CONFIG_DIRS}/htmlviewer/input.conf with
      \$HOME/.config as default value when XDG_CONFIG_DIRS is unset.

      Currently $inputconf

  -p
      Print default keyboard mapping.

  -s
      Sort input directories (default).

  -S
      Do not sort input directories.

  -t <title>
      Specify title page.

  -x <pixel_distance>
      Specify default value for bottom_pixel command.


  input.conf
      The input.conf file consists of a list of key bindings, for example:

        n next       # go to the next image with the n key
        m rotate 90  # rotates images 90 degrees

      Each line maps a key to an input command.

      In general, keys can be combined with Shift, Ctrl and Alt:

        shift+Space pgup_or_prev


  input.conf syntax
      <key> <command> [<args>...]

      Newlines always start a new binding. # starts a comment.
      To bind commands to the # key, SHARP can be used.

      <key> is either the literal character the key produces (ASCII,
      Unicode character or Javascript KeyEvent.key). See -K flag.

      <command> is the command itself. It consists of the command name
      and multiple (or none) arguments, all separated by whitespace.

  Special key names
      space
      sharp alias for #
      plus alias for +
      pgup alias for PageUp
      pgdown alias for PageDown
      up alias for ArrowUp
      down alias for ArrowDown
      left alias for ArrowLeft
      right alias for ArrowRight

      Note: aliases are insensitive case

  Commands
      next [n=1]
          Advance n images. A negative number goes back n images.

      prev [n=1]
          Equivalent to next -n.

      rotate <deg>
          Rotate an images.

      pgup

      pgdown

      pgdown_or_next [pixel_distance=bottom_pixel]
          Next image when at the bottom of the page, otherwise scroll down.

      pgup_or_prev
          Previous image when at the top of the page, otherwise scroll up.

      mode {normal|webtoon|single|double}
          - webtoon: all images in a chapter are displayed on one page.
          - single: all images are displayed on one page.
          - double: once on 2, the commands pgdown_or_next/pgup_or_prev go to
                    top/bottom of the page rather than go to the next/prev
                    image.

      info
          Show current image position.

      auto_scroll [ms_delay=800]
          Start auto scroll with specific delay.

      toggle_auto_scroll [ms_delay=800]
          Resume or stop auto scroll. Equivalent to auto_scroll when not started.

      add_interval <ms_delay>
          Add delay of auto scroll. Delay can be negative.

      set_bottom_pixel <pixel_distance>
          Number of pixels at the bottom of the page that can be skipped for
          so that pgdown_or_next, auto_scroll and toggle_auto_scroll goes to
          the next image.

          Default is 20.

      add_bottom_pixel <pixel_distance>
          Add pixel_distance. See set_bottom_pixel.

      trigger [ms_delay=200] <command>
          Allows to trigger <command> when opening the page after <ms_delay>.
          The keyboard shortcut is associated with <command>.

          You can put a key that does not exist to make no association:

            nokey trigger auto_scroll 600

            h trigger mode webtoon
            # equivalent to
            nokey trigger mode webtoon
            h mode webtoon

  COPYRIGHT
       By Jonathan Poelen
       License MIT
       https://github.com/jonathanpoelen/manga-viewer
"

declare -A modes=(
  [normal]=normalMode
  [webtoon]=webtoonPageMode
  [single]=singlePageMode
  [double]=doublePageMode
)

declare -A fns=(
  [next]=1
  [prev]=1
  [rotate]=1
  [mode]=1
  [pgup]=1
  [pgdown]=1
  [set_bottom_pixel]=1
  [add_bottom_pixel]=1
  [pgdown_or_next]=1
  [pgup_or_prev]=1
  [info]=1
  [toggle_auto_scroll]=1
  [auto_scroll]=1
  [add_interval]=1
  [trigger]=1
)

declare -A remap=(
  [space]=' '
  [left]='ArrowLeft'
  [right]='ArrowRight'
  [up]='ArrowUp'
  [down]='ArrowDown'
  [pgup]='PageUp'
  [pgdown]='PageDown'
  [sharp]='#'
  [plus]='+'
  ['\']='\\'
  [\']=\\\'
)

check_n()
{
  if [[ $2 -ne $1 ]]; then
    error="requires $1 argument, $2 but were provided"
    return 1
  fi
}

check_int()
{
  local -i n=$1
  if [[ "$1" != "$n" ]]; then
    error="bad argument: $1 is not a number"
    return 1
  fi
}

check_positive()
{
  local -i n=$1
  if [[ "$1" != "$n" ]] || [[ $n -le 0 ]]; then
    error="bad argument: $1 is not a positive number"
    return 1
  fi
}

next()
{
  if [[ $# -eq 0 ]]; then
    code='mode.advance(1);'
  else
    check_n 1 $#
    check_int "$1"
    code="mode.advance($1);"
  fi
}

prev()
{
  if [[ $# -eq 0 ]]; then
    code='mode.advance(-1);'
  else
    check_n 1 $#
    check_int "$1"
    local -i n=$1
    ((n=-n))
    code="mode.advance($n);"
  fi
}

rotate()
{
  check_n 1 $#
  check_int "$1"
  code="rotate($1);"
}

mode()
{
  check_n 1 $# || return 1

  if [[ -z "$1" ]]; then
    error="mode is empty"
    return 1
  fi

  local mode=${modes["$1"]}
  if [[ -z $mode ]]; then
    error="unknown mode '$1'"
    return 1
  fi

  code="if (mode !== $mode) { mode.stop(); mode = $mode; mode.start(); }"
}

pgup_or_prev()
{
  check_n 0 $#
  code="upOrPrev()"
}

pgdown_or_next()
{
  if [[ $# -eq 0 ]]; then
    code='downOrNext(bottomPixelDistance)'
  else
    check_n 1 $#
    check_int "$1"
    code="downOrNext($1)"
  fi
}

pgup()
{
  check_n 0 $#
  code='body.scrollTop -= body.clientHeight'
}

pgdown()
{
  check_n 0 $#
  code='body.scrollTop += body.clientHeight'
}

info()
{
  check_n 0 $#
  code='showImageInfo()'
}

auto_scroll()
{
  if [[ $# -eq 0 ]]; then
    code='startAutoScroll(800)' ;
  else
    check_n 1 $#
    check_positive "$1"
    code="startAutoScroll($1)"
  fi
}

toggle_auto_scroll()
{
  if [[ $# -eq 0 ]]; then
    code='toggleAutoScroll(800)' ;
  else
    check_n 1 $#
    check_positive "$1"
    code="toggleAutoScroll($1)"
  fi
}

add_interval()
{
  check_n 1 $#
  check_int "$1"
  code="addAutoScrollInterval($1)"
}

set_bottom_pixel()
{
  check_n 1 $# &&
  check_positive "$1" &&
  code="bottomPixelDistance = $1"
}

add_bottom_pixel()
{
  check_n 1 $#
  check_int "$1"
  code="bottomPixelDistance = max(0, bottomPixelDistance + $1)"
}

trigger()
{
  local -i delay=$1
  [[ "$1" != "$delay" ]] && delay=200 || shift

  local fn=$1
  if [[ -z ${fns[$fn]} ]]; then
    error="Unknown command '$fn'"
    return 1
  fi

  shift
  $fn "$@" || return 1
  startCode+="setTimeout(function(){$code}, $delay);"$'\n'
}

inputdirs=''
hasinput=0
sort=1
force_mode=
force_pixel_distance=
title="${@:0:200}"
declare -a cmds=()

while getopts 'sSnpKi:c:e:t:f:x:m:h?' opt ; do
  case $opt in
    s) sort=1;;
    S) sort=0;;
    n) inputconf=''
       hasinput=0;;
    i) inputconf="$OPTARG"
       hasinput=1;;
    e) htmlheader="$OPTARG";;
    c) cmds+=($OPTIND "$OPTARG");;
    t) title="$OPTARG";;
    f) inputdirs="$OPTARG";;
    m) mode "$OPTARG" && force_mode=${modes["$OPTARG"]} || {
         echo "arg $OPTIND: -m $OPTARG: $error" >&2
         exit 2
       };;
    x) set_bottom_pixel "$OPTARG" && force_pixel_distance="$OPTARG" || {
         echo "arg $OPTIND: -x $OPTARG: $error" >&2
         exit 2
       };;
    p) echo -n "$inputs";
       exit;;
    K) echo '<!DOCTYPE html>
<html><head><title>Key viewer</title><meta charset="Utf-8"/></head>
<p>Press keys on the keyboard to see what the KeyboardEvent'\''s key values is for each one.</p>
<div id="output"></div>
<script>const output = document.getElementById("output");
window.addEventListener("keydown", function(event) {
  const p = document.createElement("p");
  p.textContent = `key="${event.key}"`;
  output.appendChild(p);
}, true);
</script></body></html>';
       exit;;
    h|?) echo "$usage";
         exit;;
  esac
done
shift $(($OPTIND - 1))

shortcuts=()

parse_input_line()
{
  local key=$1
  [[ ${key[0]} != '#' ]] || return

  local fn=$2
  [[ ${fn[0]} != '#' ]] || {
    error="key without command"
    return 1
  }

  if [[ -z ${fns[$fn]} ]]; then
    error="Unknown command '$fn'"
    return 1
  fi

  shift 2

  # strip comment
  local -a args=()
  for arg in "$@"; do
    [[ ${arg[0]} != '#' ]] || break
    args+=("$arg")
  done

  $fn "${args[@]}" || error="$fn: $error"

  # extract controls and convert key to lowercase
  local -A control=([alt]=0 [ctrl]=0 [shift]=0 [meta]=0)
  local ifs="$IFS"
  IFS=+
  local -a keys=($key)
  IFS="$ifs"
  for key in "${keys[@]}"; do
    key=${key,,}
    control["$key"]=1
  done

  local newkey="${remap[$key]}"
  [[ -z $newkey ]] || key="$newkey"
  shortcuts+=("{alt: ${control[alt]}, ctrl: ${control[ctrl]}, shift: ${control[shift]}, meta: ${control[meta]}, key: '$key', action: function(){ $code }},"$'\n')
}

# read input.conf
if [[ -f "$inputconf" ]]; then
  inputs="$(<$inputconf)"
elif [[ $hasinput -eq 1 ]]; then
  echo "Unknown '$inputconf'" >&2
  exit 1
fi

errors=''

# parse input.conf
nline=0
while read -r line ; do
  ((++nline))
  [[ -n $line ]] || continue
  error=
  parse_input_line $line ||:
  [[ -z $error ]] || errors+="line $nline: $error in '$line'"$'\n'
done <<<"$inputs"

# parse -c options
for ((i=0; i < ${#cmds[@]}; i+=2)); do
  error=
  cmd="${cmds[$((i+1))]}"
  parse_input_line $cmd ||:
  [[ -z $error ]] || errors+="arg ${cmds[$i]}: $error in '$cmd'"$'\n'
done

if [[ -n $errors ]]; then
  echo -n "$errors" >&2
  exit 2
fi

[[ -z $force_mode ]] || default_mode=$force_mode
[[ -z $force_pixel_distance ]] || pixel_distance=$force_pixel_distance

# read input directories
declare -a dirs=()
if [[ -n $inputdirs ]]; then
  [[ $inputdirs != '-' ]] || inputdirs=/dev/stdin
  while read -r path; do
    dirs+=("$path")
  done <"$inputdirs"
fi


echo '<!DOCTYPE html>
<html>
<head>
	<title>Viewer: '"$title"'</title>
	<meta charset="Utf-8"/>
	<meta http-equiv="cache-control" content="max-age=0"/>
  <meta http-equiv="cache-control" content="no-cache"/>
  <meta http-equiv="expires" content="0"/>
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
  <meta http-equiv="Pragma" content="no-cache"/>
	'"$htmlheader"'
</head>
<body>
<img src="" />
<div id="info" style="display:none;z-index=10"></div>
<script type="text/javascript">
const filenames = ['

{
  if [[ $sort -eq 1 ]]; then
    find "$@" "${dirs[@]}" -type f | sort -V
  else
    for d in "$@" "${dirs[@]}"; do
      find "$d" -type f | sort -V
    done
  fi
} | sed '/\(Thumbs\.db\|\.directory\)$/d;s/"/\"/;s/^/"/;s/$/",/g'

echo '];

let ifile = +window.location.search.split("=")[1] || 0;
const img = document.getElementsByTagName("img")[0];
const body = document.documentElement;
const nbFilename = filenames.length;

const min = Math.min;
const max = Math.max;

const rotate = function(deg) {
	const r = img.getAttribute("style");
	if (r) {
		deg += Number(r.substring(25, r.length-4));
	}
	img.setAttribute("style", `transform:rotate(${deg}deg)`);
};

const toBottomOnLoad = function(image) {
  image.onload = function(e) {
    body.scrollTop = image.clientHeight;
    image.onload = undefined;
  };
};

const scrollOnImageAfterDelay = function(image, delay, addTop) {
  let trigger = false;

  const timerId = setTimeout(function() {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      image.onload = undefined;
    }
    else {
      trigger = true;
    }
  }, delay);

  image.onload = function(e) {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      clearInterval(timerId);
    }
    else {
      trigger = true;
    }
    image.onload = undefined;
  };
};

const normalMode = {
  start: function() {
    img.src = filenames[ifile];
  },
  stop: function() {},
	next: function() {
    if (ifile !== nbFilename) {
      img.src = filenames[++ifile];
      body.scrollTop = 0;
    }
	},
	prev: function() {
    if (ifile) {
      img.src = filenames[--ifile];
      toBottomOnLoad(img);
    }
	},
	advance: function(x) {
    ifile = max(0, min(ifile+x, nbFilename-1));
		img.src = filenames[ifile];
		body.scrollTop = 0;
	},
};

const doublePageMode = {
	start: function() {
		this.db = false;
	},
  stop: function() {},
	next: function() {
		if (this.dp) {
      if (ifile === nbFilename) {
        return;
      }
			img.src = filenames[++ifile];
		}
		this.dp = !this.dp;
		body.scrollTop = 0;
	},
	prev: function() {
		if (this.dp) {
      if (!ifile) {
        return;
      }
			img.src = filenames[--ifile];
      toBottomOnLoad(img);
		}
		else {
      body.scrollTop = img.clientHeight;
    }
		this.dp = !this.dp;
	},
	advance: function(x) {
		this.db = false;
    ifile = max(0, min(ifile+x, nbFilename-1));
		img.src = filenames[ifile];
		body.scrollTop = 0;
	},
};

const appendImages = function(elem, urls) {
  const nUrl = urls.length;
  for (let i = 0; i < nUrl; ++i) {
    const img = document.createElement("img");
    img.src = urls[i];
    img.dataset.i = i;
    elem.appendChild(img);
  }
};

const removeChildren = function(elem) {
  while (elem.lastChild) {
    elem.removeChild(elem.lastChild);
  }
}

const UpdateIndexFile = function() {
  const img = document.elementFromPoint(body.clientWidth / 2, 10);
  const i = img.dataset.i;
  if (i) {
    ifile = +i;
  }
};

const webtoonPageMode = {
  chapterByIndexes: null,
  updateChapter: function(){
    this.currentChapter = this.chapterByIndexes[ifile];
    removeChildren(this.eimgs);
    appendImages(this.eimgs, this.currentChapter.images);
  },
  chapterByIndexes:null,
	start: function() {
		if (!this.chapterByIndexes) {
      const chaps = new Array(nbFilename);
      let url = filenames[0];
      let images = [url];
      let seppos = url.lastIndexOf("/");
      let subs = url.substring(0, seppos);
      let startIndex = 0;
      let chap = {startIndex, images};
      let seppos2;
      chaps[0] = chap;
			for (let i = 1; i < nbFilename; ++i) {
        url = filenames[i];
        seppos2 = url.lastIndexOf("/");
        if (seppos2 == seppos && url.startsWith(subs)) {
          images.push(url);
        }
        else {
          startIndex += images.length;
          images = [url];
          chap = {startIndex, images};
          subs = url.substring(0, seppos);
        }

        chaps[i] = chap;
      }

      this.chapterByIndexes = chaps;

			this.eimgs = document.createElement("div");
		}

		document.body.removeChild(img);
		document.body.appendChild(this.eimgs);

    this.updateChapter();
    const i = this.currentChapter.startIndex;
    const image = this.eimgs.childNodes[ifile-i];
    scrollOnImageAfterDelay(image, 100, 0);
	},
	stop: function() {
		UpdateIndexFile();
		img.src = filenames[ifile];
		document.body.removeChild(this.eimgs);
		document.body.appendChild(img);
		body.scrollTop = 0;
	},
	next: function() {
    const i = this.currentChapter.startIndex + this.currentChapter.images.length;
    if (i !== nbFilename) {
      ifile = i;
      this.updateChapter();
      body.scrollTop = 0;
    }
  },
	prev: function() {
    if (this.currentChapter.startIndex) {
      ifile = this.currentChapter.startIndex - 1;
      this.updateChapter();
      const image = this.eimgs.lastChild;
      scrollOnImageAfterDelay(image, 100, 100);
    }
  },
	advance: function(x) {
    UpdateIndexFile();
    ifile = max(0, min(ifile+x, nbFilename-1));
    const chap = this.chapterByIndexes[ifile];
    if (this.currentChapter === chap) {
      body.scrollTop = this.eimgs.children[ifile - chap.startIndex].offsetTop;
    }
    else {
      body.scrollTop = 0;
      this.currentChapter = chap;
      removeChildren(this.eimgs);
      appendImages(this.eimgs, chap.images);
      const i = chap.startIndex;
      const image = this.eimgs.childNodes[ifile-i];
      scrollOnImageAfterDelay(image, 100, 0);
    }
	},
};

const singlePageMode = {
	start: function() {
		if (!this.eimgs) {
			const div = document.createElement("div");
			for (let i = 0; i < nbFilename; ++i) {
				const e = document.createElement("img");
				e.src = filenames[i];
				div.appendChild(e);
			}
			this.eimgs = div;
		}

		document.body.removeChild(img);
		document.body.appendChild(this.eimgs);

    // TODO toBottomOnLoad(img)
		body.scrollTop = this.eimgs.children[ifile].offsetTop;
	},
	stop: function() {
		UpdateIndexFile();
		img.src = filenames[ifile];
		document.body.removeChild(this.eimgs);
		document.body.appendChild(img);
		body.scrollTop = 0;
	},
	next: function() {},
	prev: function() {},
	advance: function(x) {
    UpdateIndexFile();
    ifile = max(0, min(ifile+x, nbFilename-1));
		body.scrollTop = this.eimgs.children[ifile].offsetTop;
	},
};

let mode = '$default_mode';
let bottomPixelDistance = '$pixel_distance';

mode.start();

const downOrNext = function(d) {
  if (body.scrollTop + body.clientHeight >= body.scrollHeight - d) {
    mode.next();
  }
  else {
    body.scrollTop += body.clientHeight;
  }
};

const upOrPrev = function() {
  if (body.scrollTop == 0) {
    mode.prev();
  }
  else {
    body.scrollTop -= body.clientHeight;
  }
};

//@{
let autoScrollDelay = null;
let autoScrollTimerId = null;

const startAutoScroll = function(delay) {
  console.log(`delay: ${delay}`);
  clearInterval(autoScrollTimerId);
  autoScrollDelay = delay;
  autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
};

const toggleAutoScroll = function(delay) {
  if (autoScrollDelay === null) {
    startAutoScroll(delay);
  }
  else if (autoScrollTimerId === null) {
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  else {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = null;
  }
};

const addAutoScrollInterval = function(delay) {
  autoScrollDelay = max(1, (autoScrollDelay || 800) + delay);
  if (autoScrollTimerId !== null) {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  console.log(`autoScrollDelay: ${autoScrollDelay} (+${delay})`);
};
//@}

const showImageInfo = (function() {
  const info = document.getElementById("info");
  let resumeAutoScroll = false;
  const removeInfo = function() {
    info.style.display = "none";
    window.removeEventListener("keydown", removeInfo, true);
    if (resumeAutoScroll) {
      resumeAutoScroll = false;
      if (autoScrollTimerId === null) {
        autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
      }
    }
  };
  return function() {
    if (autoScrollTimerId !== null) {
      clearInterval(autoScrollTimerId);
      autoScrollTimerId = null;
      resumeAutoScroll = true;
      info.textContent = `[${ifile}/${nbFilename}][auto-scroll: ${autoScrollDelay}ms] ${filenames[ifile]}`;
    }
    else {
      info.textContent = `[${ifile}/${nbFilename}] ${filenames[ifile]}`;
    }
    info.style.display = "";
    info.style.top = `${body.scrollTop}px`;
    window.addEventListener("keydown", removeInfo, true);
  };
})();

const actionsByKeys = (function(){
  const actionsByKeys = {};
  for (const d of [
'"${shortcuts[@]}"']) {
    let actionsByControls = actionsByKeys[d.key];
    if (!actionsByControls) {
      actionsByControls = {};
      actionsByKeys[d.key] = actionsByControls;
    }
    actionsByControls[d.alt + (d.ctrl << 1) + (d.shift << 2) + (d.meta << 3)] = d.action;
  }
  return actionsByKeys;
})();

window.addEventListener("keydown", function(e) {
  let action = actionsByKeys[e.key];
  if (action) {
    action = action[e.altKey + (e.ctrlKey << 1) + (e.shiftKey << 2) + (e.metaKey << 3)];
    if (action) {
      e.preventDefault();
      e.stopPropagation();
      action();
      //window.location.search = "?n="+ifile;
      return false;
    }
  }
	return true;
}, true);

'"$startCode"'
</script>
</body>
</html>'
