#!/usr/bin/env bash

set -e

inputs='# default input.conf
space pgdown_or_next
shift+space pgup_or_prev

space restrict webtoon pgdown_or_next 98
space restrict all pgdown_or_next 98
shift+space restrict webtoon pgup_or_prev 98
shift+space restrict all pgup_or_prev 98

z next -5
x next 5
a next -12
s next 12
q next -30
w next 30
e next -100
r next 100

left prev
right next

ctrl+left  next -5
ctrl+right next 5
ctrl+up    next 12
ctrl+down  next -12

< next_chap -1
> next_chap 1

| prev
c pgup_or_prev
v prev
b pgup_or_prev 50
n pgdown_or_next 50
. prev
/ pgdown_or_next

m rotate -90
, rotate 90

g goto
^ goto 0
$ goto -1

h mode webtoon
j mode double
k mode normal
l mode normal_or_double

d info
o info

t toggle_auto_scroll
u add_interval -25
i add_interval 25

y newtab
Y newtab foreground

# Mouse shortcuts

left_click pgdown_or_next
shift+left_click pgup_or_prev

ctrl+left_click next_chap
shift+ctrl+left_click next_chap -1

alt+left_click newtab
altgr+left_click newtab

@ mouse_assistance

# extra

F1 shortcuts
F8 search
F10 open

F6 save
F7 load
'

config="${XDG_CONFIG_DIRS:-${XDG_DATA_HOME:-$HOME}/.config}"/htmlviewer
inputconf="$config"/input.conf
triggered=''

co=$'\x1b[31m'  # option name
cv=$'\x1b[32m'  # parameter name (cf. <xxxx>)
cl=$'\x1b[34m'  # list of parameter values (cf. {xxx|yyy})
cd=$'\x1b[37m'  # default value
cr=$'\x1b[m'    # reset color
usage() {
  echo "Generate a html viewer file

  htmlviewer [$co-a$cr|$co-A$cr] [$co-n$cr] [$co-s$cr] [$co-S$cr] [$co-c$cr <${cv}command${cr}>] [$co-e$cr <${cv}html${cr}>] [$co-f$cr <${cv}filename${cr}>]
             [$co-i$cr <${cv}filename${cr}>] [$co-m$cr {${cl}normal${cr}|${cl}double${cr}|${cl}normal_or_doube${cr}|${cl}webtoon${cr}|${cl}all${cr}}]
             [$co-t$cr <${cv}title${cr}>] [$co-x$cr <${cv}pixel_distance${cr}>] directory...
  htmlviewer $co-p$cr
  htmlviewer $co-K$cr
  htmlviewer $co-h$cr"
}

help() {
  echo "
  $co-a$cr
      Builds a web page that can open images from the viewer.

  $co-A$cr
      Builds a web page that lists the shortcuts available for the current
      configuration.

  $co-c$cr <${cv}command${cr}>
      Add a command. See input.conf syntax.

  $co-e$cr <${cv}html${cr}>
      Specify content of html header. By default its contains the html style.

  $co-f$cr <${cv}filename${cr}>
      Read directories from <${cv}filename${cr}>. If - is specified as filename,
      directories are read from the standard input.

        find -type d | fzf | htmlviewer -f- > view.html

  $co-i$cr <${cv}filename${cr}>
      Specify configuration file. See input.conf.

  $co-h$cr
      Show this help.

  $co-K$cr
      Generates a html file which displays the name of the keys and
      mouse buttons.

  $co-m$cr {${cl}normal${cr}|${cl}double${cr}|${cl}normal_or_double${cr}|${cl}webtoon${cr}|${cl}all${cr}}
      Specify default mode.

  $co-n$cr
      Do not load default configuration files.

      By default load $cd\${XDG_CONFIG_DIRS}/htmlviewer/input.conf$cr with
      $cd\$HOME/.config$cr as default value when XDG_CONFIG_DIRS is unset.

      Currently $cd$inputconf$cr

  $co-p$cr
      Print default keyboard mapping.

  $co-s$cr
      Sort input directories (default).

  $co-S$cr
      Do not sort input directories.

  $co-t$cr <${cv}title${cr}>
      Specify title page.

  $co-x$cr <${cv}pixel_distance${cr}>
      Specify default value for bottom_pixel command.


  input.conf
      The input.conf file consists of a list of mouse and key bindings,
      for example:

        n next       # go to the next image with the n key
        m rotate 90  # rotates images 90 degrees

      Each line maps a key to an input command.

      In general, keys can be combined with ${cl}Shift${cr}, ${cl}Ctrl${cr}, ${cl}Alt${cr}, ${cl}Meta${cr} and ${cl}AltGr${cr}
      (Modifiers are case insensitive):

        shift+Space pgup_or_prev

      ${cl}AltGr${cr} and ${cl}Shift${cr} are optional.

        # the following 2 commands are equivalent
        shift+y newtab
        Y newtab


  input.conf syntax
      <${cv}key${cr}> <${cv}command${cr}> [<${cv}args${cr}>...]

      Newlines always start a new binding. # starts a comment.
      To bind commands to the # key, SHARP can be used.

      <${cv}key${cr}> is either the literal character the key produces (ASCII,
      Unicode character or Javascript KeyEvent.key). See ${co}-K${cr} flag.

      <${cv}command${cr}> is the command itself. It consists of the command name
      and multiple (or none) arguments, all separated by whitespace.

  Special key names
      ${cl}space${cr}
      ${cl}sharp${cr} alias for #
      ${cl}plus${cr} alias for +
      ${cl}pgup${cr} alias for PageUp
      ${cl}pgdown${cr} alias for PageDown
      ${cl}up${cr} alias for ArrowUp
      ${cl}down${cr} alias for ArrowDown
      ${cl}left${cr} alias for ArrowLeft
      ${cl}right${cr} alias for ArrowRight
      ${cl}left_click${cr} for click0
      ${cl}middle_click${cr} for click1
      ${cl}right_click${cr} for click2

      Note: aliases are insensitive case

  Commands
      ${co}next${cr} [${cv}n${cr}=${cd}1${cr}]
          Advance n images. A negative number goes back ${cv}n${cr} images.

      ${co}prev${cr} [${cv}n${cr}=${cd}1${cr}]
          Equivalent to next -${cv}n${cr}.

      ${co}next_chap${cr} [${cv}n${cr}=${cd}1${cr}]
          Advance n directories. A negative number goes back ${cv}n${cr} directories.

      ${co}prev_chap${cr} [${cv}n${cr}=${cd}1${cr}]
          Equivalent to next -${cv}n${cr}.

      ${co}pgup${cr} [${cv}percent${cr}=${cd}100${cr}]

      ${co}pgdown${cr} [${cv}percent${cr}=${cd}100${cr}]

      ${co}pgdown_or_next${cr} [${cv}percent${cr}=${cd}100${cr}] [${cv}pixel_distance${cr}=${cd}\$bottom_pixel${cr}]
          Next image when at the bottom of the page, otherwise scroll down.

      ${co}pgup_or_prev${cr} [${cv}percent${cr}=${cd}100${cr}]
          Previous image when at the top of the page, otherwise scroll up.

      ${co}goto${cr} [${cv}image_position${cr}]
          Opens a page selection window.

          When '${cv}image_position${cr}' is specified, the nth image is opened directly.
          A negative number begins at the end and too large a number selects
          the last frame.

      ${co}rotate${cr} <${cv}deg${cr}>
          Rotate an images.

      ${co}newtab${cr} [{${cl}background${cr}|${cl}foreground${cr}|${cl}window${cr}}]
          Open the current image in a background tab (default), foreground tab
          or new window.

          Keyboard shortcuts containing ctrl or alt may malfunction with this
          option. No problem with mouse shortcuts.

          window depends on browser options and may open a foreground tab.

      ${co}mode${cr} {${cl}normal${cr}|${cl}double${cr}|${cl}normal_or_double${cr}|${cl}webtoon${cr}|${cl}all${cr}} [${cv}image_limit${cr}=${cd}0${cr}]
          - ${cl}normal${cr}: One image at a time.
          - ${cl}double${cr}: Once on 2, the commands ${co}pgdown_or_next${cr}/${co}pgup_or_prev${cr} go to
                    top/bottom of the page rather than go to the next/prev
                    image.
          - ${cl}normal_or_double${cr}: Use double page mode for images whose width is
                              greater than the height, otherwise use the normal
                              mode.
          - ${cl}webtoon${cr}: All images in a chapter are displayed one below the other.
          - ${cl}all${cr}: All images are displayed one below the other.

          '${cv}image_limit${cr}' specifies the maximum number of images displayed per
          page. ${cv}0${cr} for no limit.

      ${co}info${cr}
          Show current image position.

      ${co}auto_scroll${cr} [${cv}ms_delay${cr}=${cd}800${cr}]
          Start auto scroll with specific delay.

      ${co}toggle_auto_scroll${cr} [${cv}ms_delay${cr}=${cd}800${cr}]
          Resume or stop auto scroll. Equivalent to ${co}auto_scroll${cr} when not started.

      ${co}add_interval${cr} <${cv}ms_delay${cr}>
          Add delay of auto scroll. Delay can be negative.

      ${co}set_bottom_pixel${cr} <${cv}pixel_distance${cr}>
          Number of pixels at the bottom of the page that can be skipped for
          so that ${co}pgdown_or_next${cr}, ${co}auto_scroll${cr} and ${co}toggle_auto_scroll${cr} goes to
          the next image.

          Default is ${cd}20${cr}.

      ${co}add_bottom_pixel${cr} <${cv}pixel_distance${cr}>
          Add ${cv}pixel_distance${cr}. See ${co}set_bottom_pixel${cr}.

      ${co}trigger${cr} [${cv}ms_delay${cr}=${cd}0${cr}] <${cv}command${cr}>
          Allows to trigger <${cv}command${cr}> when opening the page after <${cv}ms_delay${cr}>.
          The keyboard shortcut is associated with <${cv}command${cr}>.

          You can put a key that does not exist to make no association:

            nokey trigger 200 auto_scroll 600

            h trigger mode webtoon
            # is equivalent to
            nokey trigger mode webtoon
            h mode webtoon

      ${co}mouse${cr} {${cl}top${cr}|${cl}bottom${cr}|${cl}left${cr}|${cl}right${cr}|${cl}top_left${cr}|${cl}top_right${cr}|${cl}bottom_left${cr}|${cl}bottom_right${cr}} <${cv}command${cr}>
          Execute <${cv}command${cr}> only when the mouse pointer is in a certain area.

          Note: Only works with mouse shortcuts.

      ${co}mouse_assistance${cr}
          Enable or disable the display of mouse area.

      ${co}restrict${cr} {${cl}normal${cr}|${cl}double${cr}|${cl}normal_or_double${cr}|${cl}webtoon${cr}|${cl}all${cr}} <${cv}command${cr}>
          Enable a shortcut for a specific mode.

      ${co}shortcuts${cr}
          Show shortcuts.

      ${co}open${cr}
          Open directories.

      ${co}search${cr} [{${cl}chapter${cr}|${cl}image${cr}}
             |{${cl}then_by_img${cr}}
             |{${cl}case_sensitive${cr}|${cl}case_insensitive${cr}|${cl}uppercase_only${cr}}
             |{${cl}accent_sensitive${cr}|${cl}accent_insensitive${cr}|${cl}accent_only${cr}}
             |{${cl}word${cr}|${cl}fuzzy${cr}|${cl}text${cr}|${cl}regex${cr}}
             ]...
          Show a finder.
          Default are ${cd}chapter${cr}, ${cd}uppercase_only${cr}, ${cd}accent_only${cr} and ${cd}word${cr}.

          - ${cl}chapter${cr}, ${cl}img${cr}:
              Indicates from which part the urls will be cut.

          - ${cl}then_by_img${cr}:
              Activate recursive filters. for example, after selecting a chapter,
              a new filter can on the image of it.

          - ${cl}case_sensitive${cr}, ${cl}case_insensitive${cr}, ${cl}uppercase_only${cr}:
              Indicates whether upper and lower case letters should be
              considered the same.
              '${cl}uppercase_only${cr}' searches case insensitive for lowercase letters
              and case sensitive for uppercase letters. Does not work with
              regex mode.

          - ${cl}accent_sensitive${cr}, ${cl}accent_insensitive${cr}, ${cl}accent_only${cr}:
              Indicates whether accents should be ignored.
              '${cl}accent_only${cr}' ignore accent for unaccented letters and match
              accent for accented letters. Does not work with regex mode.

          - ${cl}word${cr}, ${cl}fuzzy${cr}, ${cl}text${cr}, ${cl}regex${cr}:
              Algorithm used for the filter.

      ${co}save${cr}
          Save position and mode.

      ${co}load${cr}
          Load saved position and mode.


  COPYRIGHT
       By Jonathan Poelen
       MIT License
       https://github.com/jonathanpoelen/manga-viewer
"
}

declare -A fns=(
  [next]=1
  [prev]=1
  [next_chap]=1
  [prev_chap]=1
  [mode]=1
  [pgup]=1
  [pgdown]=1
  [goto]=1
  [rotate]=1
  [newtab]=1
  [pgdown_or_next]=1
  [pgup_or_prev]=1
  [info]=1
  [toggle_auto_scroll]=1
  [auto_scroll]=1
  [add_interval]=1
  [set_bottom_pixel]=1
  [add_bottom_pixel]=1
  [trigger]=1
  [mouse]=1
  [mouse_assistance]=1
  [restrict]=1
  [shortcuts]=1
  [open]=1
  [search]=1
  [save]=1
  [load]=1
)

declare -A remap=(
  [space]=' '
  [left]='ArrowLeft'
  [right]='ArrowRight'
  [up]='ArrowUp'
  [down]='ArrowDown'
  [pgup]='PageUp'
  [pgdown]='PageDown'
  [sharp]='#'
  [plus]='+'
  [left_click]='click0'
  [middle_click]='click1'
  [right_click]='click2'
  ['\']='\\'
  [\']=\\\'
)

declare -A show_shortcut_map=(
  [ArrowLeft]=Left
  [ArrowRight]=Right
  [ArrowUp]=Up
  [ArrowDown]=Down
  [click0]=LeftClick
  [click1]=MiddleClick
  [click2]=RightClick
)

declare -A mousezone=(
  [xtop]=1
  [xbottom]=2
  [xleft]=4
  [xright]=8
  [xtop_left]=5
  [xleft_top]=5
  [xright_top]=9
  [xtop_right]=9
  [xbottom_left]=6
  [xleft_bottom]=6
  [xbottom_right]=10
  [xright_bottom]=10
  [xall]=15
)

check_n()
{
  if (( $2 != $1 )); then
    error="requires $1 argument, $2 but were provided"
    return 1
  fi
}

check_int()
{
  local -i n=$1
  if [[ "$1" != "$n" ]]; then
    error="bad argument: $1 is not a number"
    return 1
  fi
}

check_positive()
{
  local -i n=$1
  if [[ "$1" != "$n" ]] || (( $n < 0 )); then
    error="bad argument: $1 is not a positive number"
    return 1
  fi
}

init_local_mode()
{
  case "$1" in
    normal)  mode=normalMode;;
    double)  mode=doublePageMode;;
    webtoon) mode=webtoonMode;;
    normal_or_double) mode=normalOrDoublePageMode;;
    all)     mode=allMode;;
    *) error="Unknown mode '$1'";
       return 1;;
  esac
}

subcomand()
{
  local fn=$1
  if [[ -z ${fns[$fn]} ]]; then
    error="Unknown command '$fn'"
    return 1
  fi

  shift
  cmd_$fn "$@"
}


cmd_next()
{
  if (( $# == 0 )); then
    code='mode.advance(1);'
  else
    check_n 1 $#
    check_int "$1"
    code="mode.advance($1);"
  fi
}

cmd_prev()
{
  if (( $# == 0 )); then
    code='mode.advance(-1);'
  else
    check_n 1 $#
    check_int "$1"
    local -i n=$1
    ((n=-n))
    code="mode.advance($n);"
  fi
}

cmd_next_chap()
{
  if (( $# == 0 )); then
    code='mode.advanceChap(1);'
  else
    check_n 1 $#
    check_int "$1"
    code="mode.advanceChap($1);"
  fi
}

cmd_prev_chap()
{
  if (( $# == 0 )); then
    code='mode.advanceChap(-1);'
  else
    check_n 1 $#
    check_int "$1"
    local -i n=$1
    ((n=-n))
    code="mode.advanceChap($n);"
  fi
}

cmd_goto()
{
  if (( $# == 0 )); then
    code='showGoto();'
  else
    check_n 1 $#
    check_int "$1"
    code="gotoImage($1);"
  fi
}

cmd_rotate()
{
  check_n 1 $#
  check_int "$1"
  code="rotate($1);"
}

cmd_newtab()
{
  if (( $# == 0 )); then
    code='openInNewTab(0);'
  else
    check_n 1 $#
    case "$1" in
      window) code="openInNewTab(2);";;
      foreground) code="openInNewTab(1);";;
      background) code="openInNewTab(0);";;
      *) error="Unknown '$1'"; return 1;;
    esac
  fi
}

cmd_mode()
{
  local mode image_limit=0
  init_local_mode "$1"

  if (( $# > 1 )); then
    check_n 2 $#
    check_int "$2"
    image_limit="$2"
  fi

  code="selectMode($mode, $image_limit);"
}

cmd_pgup_or_prev()
{
  if (( $# == 0 )); then
    code='upOrPrev(body.clientHeight);'
  else
    check_n 1 $#
    check_int "$1"
    code="upOrPrev(body.clientHeight * ($1 / 100));"
  fi
}

cmd_pgdown_or_next()
{
  if (( $# == 0 )); then
    code='downOrNext(bottomPixelDistance, body.clientHeight);'
  elif (( $# == 1 )); then
    check_int "$1"
    code="downOrNext(bottomPixelDistance, body.clientHeight * ($1 / 100));"
  else
    check_n 2 $#
    check_int "$1"
    check_positive "$2"
    code="downOrNext($2, body.clientHeight * ($1 / 100));"
  fi
}

cmd_pgup()
{
  if (( $# == 0 )); then
    code='body.scrollTop -= body.clientHeight;'
  else
    check_n 1 $#
    check_int "$1"
    code="body.scrollTop -= body.clientHeight * ($1 / 100);"
  fi
}

cmd_pgdown()
{
  if (( $# == 0 )); then
    code='body.scrollTop += body.clientHeight;'
  else
    check_n 1 $#
    check_int "$1"
    code="body.scrollTop += body.clientHeight * ($1 / 100);"
  fi
}

cmd_info()
{
  check_n 0 $#
  code='showImageInfo();'
}

cmd_auto_scroll()
{
  if (( $# == 0 )); then
    code='startAutoScroll(800);' ;
  else
    check_n 1 $#
    check_positive "$1"
    code="startAutoScroll($1);"
  fi
}

cmd_toggle_auto_scroll()
{
  if (( $# == 0 )); then
    code='toggleAutoScroll(800);' ;
  else
    check_n 1 $#
    check_positive "$1"
    code="toggleAutoScroll($1);"
  fi
}

cmd_add_interval()
{
  check_n 1 $#
  check_int "$1"
  code="addAutoScrollInterval($1);"
}

cmd_set_bottom_pixel()
{
  check_n 1 $# &&
  check_positive "$1" &&
  code="bottomPixelDistance = $1;"
}

cmd_add_bottom_pixel()
{
  check_n 1 $#
  check_int "$1"
  code="bottomPixelDistance = max(0, bottomPixelDistance + $1);"
}

cmd_trigger()
{
  local -i delay=$1
  [[ "$1" != "$delay" ]] && delay=0 || shift

  subcomand "$@"
  triggered+="{action: function(){$code}, delay: $delay},"$'\n'
}

cmd_mouse()
{
  local zone=${mousezone["x$1"]}
  if [[ -z $zone ]]; then
    error="Unknown zone '$1'"
    return 1
  fi

  shift
  subcomand "$@"
  code="if (isInZone(arguments[0], $zone)) { $code }"
}

cmd_mouse_assistance()
{
  check_n 0 $#
  code='toggleMouseAssistance()'
}

cmd_restrict()
{
  init_local_mode "$1"
  shift
  subcomand "$@"
}

cmd_shortcuts()
{
  check_n 0 $#
  code='showShorcuts();'
}

cmd_open()
{
  check_n 0 $#
  code='showLoader();'
}

cmd_search()
{
  local i
  code='let options = SEARCH_BY_CHAPTER | SEARCH_THEN_BY_IMAGE | SEARCH_UPPERCASE_ONLY | SEARCH_ACCENT_ONLY | SEARCH_MODE_WORD;'
  while (($# != 0)); do
    case "${1//-/_}" in
      chap|chapter) code+='options = options & ~SEARCH_BY_MASK | SEARCH_BY_CHAPTER;';;
      img|image)    code+='options = options & ~SEARCH_BY_MASK | SEARCH_BY_IMAGE;';;

      then_by_img)  code+='options = options & ~SEARCH_THEN_BY_MASK | SEARCH_THEN_BY_IMAGE;';;

      case_sensitive)   code+='options = options & ~SEARCH_CASE_SENSITIVITY_MASK | SEARCH_CASE_SENSITIVE;';;
      case_insensitive) code+='options = options & ~SEARCH_CASE_SENSITIVITY_MASK | SEARCH_CASE_INSENSITIVE;';;
      uppercase_only)   code+='options = options & ~SEARCH_CASE_SENSITIVITY_MASK | SEARCH_UPPERCASE_ONLY;';;

      accent_sensitive)   code+='options = options & ~SEARCH_ACCENT_SENSITIVITY_MASK | SEARCH_ACCENT_SENSITIVE;';;
      accent_insensitive) code+='options = options & ~SEARCH_ACCENT_SENSITIVITY_MASK | SEARCH_ACCENT_INSENSITIVE;';;
      accent_only)        code+='options = options & ~SEARCH_ACCENT_SENSITIVITY_MASK | SEARCH_ACCENT_ONLY;';;

      word)  code+='options = options & ~SEARCH_MODE_MASK | SEARCH_MODE_WORD;';;
      fuzzy) code+='options = options & ~SEARCH_MODE_MASK | SEARCH_MODE_FUZZY;';;
      text)  code+='options = options & ~SEARCH_MODE_MASK | SEARCH_MODE_TEXT;';;
      regex) code+='options = options & ~SEARCH_MODE_MASK | SEARCH_MODE_REGEX;';;

      *) error="Unknown mode '$1'";
        return 1;;
    esac
    shift
  done
  code+='showSearcher(options);'
}

cmd_save() {
  check_n 0 $#
  code='savePosition();'
}

cmd_load() {
  check_n 0 $#
  code='loadPosition();'
}


minihelp()
{
  usage
  echo
  echo "input.conf path: $cd$inputconf$cr"
  if [[ ! -f "$inputconf" ]]; then
    echo "  But not found, a default configuration will be used (see $co-p$cr)."
  fi
  echo
  echo "Use $co-a$cr for create a view without directory. Directories to be loaded"
  echo 'will be asked when opening the html file.'
  echo
  echo "Use $co-h$cr for more information."
}

typeset -i standalone=0 sort=1 hasinput=0
inputdirs=''
htmlheader=
force_mode_code=
force_pixel_distance_code=
title=
declare -a cmds=()

while getopts 'aAsSnpKi:c:e:t:f:x:m:h?' opt ; do
  case $opt in
    s) sort=1;;
    S) sort=0;;
    n) inputconf=''
       hasinput=0;;
    i) inputconf="$OPTARG"
       hasinput=1;;
    e) htmlheader="$OPTARG";;
    c) cmds+=($OPTIND "$OPTARG");;
    t) title="$OPTARG";;
    f) inputdirs="$OPTARG";;
    m) cmd_mode $OPTARG && force_mode_code=$code || {
         echo "arg $OPTIND: -m $OPTARG: $error" >&2
         exit 2
       };;
    x) cmd_set_bottom_pixel "$OPTARG" && force_pixel_distance_code="$OPTARG" || {
         echo "arg $OPTIND: -x $OPTARG: $error" >&2
         exit 2
       };;
    p) echo -n "$inputs";
       exit;;
    a) standalone=1;;
    A) standalone=2;;
    h) usage; help; exit;;
    K) echo '<!DOCTYPE html>
<html><head><title>Key viewer</title><meta charset="Utf-8"/></head>
<noscript><p>Javascript must be enabled</p></noscript>
<p>Press a keyboard key or mouse click to see the associated values.</p>
<div id="output"></div>
<script>const output = document.getElementById("output");
window.addEventListener("keydown", function(event) {
  const p = document.createElement("p");
  p.textContent = `key="${event.key}"`;
  output.appendChild(p);
}, true);
function mouseEvent(event) {
  const p = document.createElement("p");
  p.textContent = `key="click${event.button}"`;
  output.appendChild(p);
};
window.addEventListener("click", mouseEvent, true);
window.addEventListener("auxclick", mouseEvent, true);
</script></body></html>';
       exit;;
    ?) minihelp >&2;
       exit 2;;
  esac
done
shift $(($OPTIND - 1))

if (( $# == 0 )) && (( ! $standalone )); then
  minihelp >&2
  exit 1
fi

if [[ -z "$title" ]]; then
  if (( $standalone == 2 )); then
    title='Shortcut list for manga-viewer / htmlviewer'
  else
    title="Directories: $@"
    title="${title:0:200}"
  fi
fi

shortcuts=()
raw_shortcuts=()
declare -A shortcuts_by_mode=()

parse_input_line()
{
  local key=$1
  [[ ${key[0]} != '#' ]] || return

  local fn=$2
  [[ ${fn[0]} != '#' ]] || {
    error="key without command"
    return 1
  }

  if [[ -z ${fns[$fn]} ]]; then
    error="Unknown command '$fn'"
    return 1
  fi

  shift 2

  # strip comment
  local -a args=()
  for arg in "$@"; do
    [[ ${arg[0]} != '#' ]] || break
    args+=("$arg")
  done

  local mode # set by restrict
  cmd_$fn "${args[@]}" || error="$fn: $error"

  # extract controls and convert key to lowercase
  local -A controls=([alt]=0 [ctrl]=0 [shift]=0 [meta]=0 [altgr]=0)
  local ifs="$IFS"
  IFS=+
  local -a keys=($key)
  IFS="$ifs"

  local lowerkey
  for key in "${keys[@]}"; do
    lowerkey="${key,,}"
    controls["${lowerkey}"]=1
  done

  local newkey="${remap[${lowerkey}]}"
  [[ -z $newkey ]] || key="$newkey"
  local shortcut="{alt: ${controls[alt]}, ctrl: ${controls[ctrl]}, shift: ${controls[shift]}, meta: ${controls[meta]}, altgr: ${controls[altgr]}, key: '$key', action: function(){ $code }},"$'\n'

  if [[ -z $mode ]]; then
    shortcuts+=("$shortcut")
  else
    shortcuts_by_mode[$mode]+="$shortcut"
  fi

  # shortcut for help
  if [[ $key != nokey ]]; then
    local display_key="${key}"
    if (( ${#key} > 1 )); then
      display_key="${show_shortcut_map[$key]}"
      if [[ -z $display_key ]]; then
        display_key="${key^}"
      fi
    else
      display_key="${display_key/ /Space}"
      display_key="${display_key/&/&amp;}"
      display_key="${display_key/</&lt;}"
    fi

    local cmdraw
    # remove trigger prefix
    if [[ $fn = trigger ]]; then
      # remove delay prefix
      if [[ ${args[@]} = [0-9] ]]; then
        local tmp=("${args[@]}")
        tmp[0]=''
        cmdraw="${tmp[@]}"
      else
        cmdraw="${args[@]}"
      fi
    else
      cmdraw="$fn ${args[@]}"
    fi

    [[ 0 != ${controls[meta]} ]] && display_key="Meta+$display_key"
    [[ 0 != ${controls[altgr]} ]] && display_key="AltGr+$display_key"
    [[ 0 != ${controls[shift]} ]] && display_key="Shift+$display_key"
    [[ 0 != ${controls[alt]} ]] && display_key="Alt+$display_key"
    [[ 0 != ${controls[ctrl]} ]] && display_key="Ctrl+$display_key"
    raw_shortcuts+=("<tr><td>$display_key</td><td>$cmdraw</td></tr>")
  fi
}

# read input.conf
if [[ -f "$inputconf" ]]; then
  inputs="$(<$inputconf)"
elif (( $hasinput )); then
  echo "Unknown '$inputconf'" >&2
  exit 1
fi

errors=''

# parse input.conf
nline=0
while read -r line ; do
  ((++nline))
  [[ -n $line ]] || continue
  error=
  parse_input_line $line ||:
  [[ -z $error ]] || errors+="line $nline: $error in '$line'"$'\n'
done <<<"$inputs"

# parse -c options
for ((i=0; i < ${#cmds[@]}; i+=2)); do
  error=
  cmd="${cmds[$((i+1))]}"
  parse_input_line $cmd ||:
  [[ -z $error ]] || errors+="arg ${cmds[$i]}: $error in '$cmd'"$'\n'
done

if [[ -n $errors ]]; then
  echo -n "$errors" >&2
  exit 2
fi

# read input directories
declare -a dirs=()
if [[ -n $inputdirs ]]; then
  [[ $inputdirs != '-' ]] || inputdirs=/dev/stdin
  while read -r path; do
    dirs+=("$path")
  done <"$inputdirs"
fi

title="${title//&/&amp;}"
title="${title//</&lt;}"

echo '<!DOCTYPE html>
<!-- https://github.com/jonathanpoelen/manga-viewer -->
<html>
<head>
  <meta charset="Utf-8"/>
  <title>'"$title"'</title>
  <meta http-equiv="cache-control" content="max-age=0"/>
  <meta http-equiv="cache-control" content="no-cache"/>
  <meta http-equiv="expires" content="0"/>
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <style>
div, body {
  margin:0;
  padding:0;
  background:#000;
}

img {
  display:block;
  margin:auto;
  max-width:100%;
}

#info, #goto, #mouseAssistance {
  display:none;
  z-index:10;
  position:absolute;
  top:0px;
}

#info, #goto {
  padding:.5em;
  color:#000;
  background:#eee;
  border:1px #000 solid;
}

#mouseAssistance {
  width:100%;
  height:100%;
  grid-template-columns:auto auto;
  background:transparent;
}
#mouseAssistance > span {
  margin:0;
  padding:0;
  display:block;
  background:transparent;
  border:1px yellow solid;
  border-left:0;
  border-bottom:0;
}
#mouseAssistance > span:hover {
  background: rgba(0,0,0,.2);
}
#mouseAssistance > span:nth-child(1), #mouseAssistance > span:nth-child(2) {
  border-top:0;
}

#shortcuts, #loader, #searcher {
  display:none;
  width: 100%;
}

#repositoryUrl {
  background:#050505;
  margin: auto;
  padding: .5em;
  text-align: center;
  line-height: 2.5em;
}

#repositoryUrl, #repositoryUrl > a {
  color: #888;
}
#repositoryUrl > a:hover {
  color: #aaa;
}

#loaderForm {
  display: table;
  background:#eee;
  margin: auto;
  padding: 2em;
  text-align:center;
}

#loaderForm > p {
  color: #777;
}

#loaderForm > label, #loaderForm > input {
  display: block;
  margin: 1em;
}

#loaderForm > input {
  display: inline-block;
}

#loaderForm > fieldset > label {
  text-align: left;
  display: block;
}
.urlmode {
  font-size: .8em;
}
.urlmode, .urlmode > a {
  color: #888;
}
.urlmode > a:hover {
  color: #606060;
}

#shortcuts > table {
  background: #eee;
  margin: auto;
  padding: 0;
  border-spacing: 0;
}

#shortcuts > table tr:nth-child(even) {
  background: #ddd;
}

#shortcuts > table td {
  padding: .5em;
  padding-right: 2em;
}

#shortcuts > table td:first-child {
  text-align: right;
  font-weight: bold;
  padding-left: 2em;
  padding-right: .5em;
}

#searcher {
  background:#eee;
  padding: 0 10%;
  margin: 0;
  width: 80%
}

#searchInputMode, #searchResultList, #searchClose, #searchOptions {
  display: block;
  width: 100%;
  margin: .5em 0;
}
#searchInputMode {
  width: calc(100% - .5em);
}

#searchResultList {
  background: #ddd;
}

#searchResultList > a {
  display: block;
  margin: 0;
  padding: .2em .5em;
  border: 1px solid black;
  border-top: 0;
  text-decoration: none;
  color: black;
}

#searchResultList > a:first-child {
  border-top: 1px solid black;
}

#searchResultList > a:nth-child(even) {
  background: #eee;
}

b {
  background: #ffb;
}

#searchResultList > a:nth-child(even) > b {
  background: #ffc;
}

#searchResultList > a:hover {
  background: #e5efe5;
}

#searchResultList > a:focus, #searchResultList > a:active, #searchResultList > a#activeSearch {
  text-decoration: underline;
  color: #b81a2f;
}

#searchOptions > label {
  border-left: 1px solid black;
  padding: 0 .5em;
}

#searcher {
  flex-flow: column;
  height: 100vh;
}
#searchInputMode {
  flex: 0 1 unset;
}
#searchInputError {
  flex: 2 1 unset;
}
#searchOptions {
  flex: 3 1 unset;
}
#searchClose {
  flex: 4 1 unset;
}
#searchResultList {
  flex: 5 1 auto;
  overflow: auto;
}
  </style>
  '"$htmlheader"'
</head>
<body>'

if (( $standalone == 2 )); then
  echo '<section id="shortcuts" style="display:block"><table>'"${raw_shortcuts[@]}"'</table></section>
</body>
</html>'
  exit
fi

echo '<noscript><p style="background:#eee;color:black;text-align:center;font-size:2em">Javascript must be enabled</p></noscript>

<img src="" class="imgWrapper"/>

<section id="info"></section>

<section id="goto">
  <form id="gotoForm">
    <p><label>Image: <input type="number" id="gotoImage" min="1"/> / <span id="gotoImageMax"></span></label> <span id="gotoImageInChapter"></span></p>
    <p><label>Chapter: <input type="number" id="gotoChapter" min="1"/> / <span id="gotoChapterMax"></span></label> <span id="gotoNameOfChapter"></span></p>
    <p><input type="button" value="Cancel (or escape)" id="gotoCancel"/> <input type="submit"/></p>
  </form>
</section>

<section id="loader">
  <form id="loaderForm">
    <label id="prefixLabel">Directory Prefix: <input id="prefix" type="text"/></label>
    <label>Directories: <input id="dirs" type="file" webkitdirectory="" multiple=""/></label>
    <p id="finalpath"></p>
    <fieldset>
      <legend>Mode:</legend>
      <label><input type="radio" id="mode_normal" name="mode" value="normal"/>Normal <span class="urlmode">(url: <a href="?mode=normal">?mode=normal</a>)</span></label>
      <label><input type="radio" id="mode_double" name="mode" value="double"/>Double page <span class="urlmode">(url: <a href="?mode=double">?mode=double</a>)</span></label>
      <label><input type="radio" id="mode_webtoon" name="mode" value="webtoon"/>Webtoon <span class="urlmode">(url: <a href="?mode=webtoon">?mode=webtoon</a>)</span></label>
      <label><input type="radio" id="mode_normal_or_double" name="mode" value="normal_or_double"/>Normal or Double page <span class="urlmode">(url: <a href="?mode=normal_or_double">?mode=normal_or_double</a>)</span></label>
      <label><input type="radio" id="mode_all" name="mode" value="all"/>All page <span class="urlmode">(url: <a href="?mode=all">?mode=all</a>)</span></label>
    </fieldset>
    <input type="submit"/>
    <input id="closeLoader" type="button" value="Cancel (or escape)"/>
  </form>
  <p id="repositoryUrl">
    <a href="https://jonathanpoelen.github.io/manga-viewer/shortcuts.html">Mouse / Keyboard Shortcuts</a><br/>
    Project: <a href="https://github.com/jonathanpoelen/manga-viewer">https://github.com/jonathanpoelen/manga-viewer</a>
  </p>
</section>

<section id="searcher">
  <input id="searchInputMode" type="text"/>
  <div id="searchInputError" type="text"></div>
  <section id="searchOptions">
    <select id="searchBy">
      <option>By Chapter</option>
      <option>By Image</option>
    </select>
    <label><input type="checkbox" id="searchThenBy">Then by Image</option></label>
    <label>Mode: <select id="searchMode">
      <option>Word</option>
      <option>Fuzzy</option>
      <option>Plain Text</option>
      <option>Regex</option>
    </select></label>
    <label>Case sensitivity: <select id="searchCaseSensitivity">
      <option>Sensitive</option>
      <option>Insensitive</option>
      <option>Upper Only</option>
    </select></label>
    <label>Accent sensitivity: <select id="searchAccentSensitivity">
      <option>Sensitive</option>
      <option>Insensitive</option>
      <option>Accent Only</option>
    </select></label>
  </section>
  <input id="searchClose" type="button" value="Cancel (or escape)"/>
  <div id="searchResultList"></div>
</section>

<section id="shortcuts"><table>'"${raw_shortcuts[@]}"'</table></section>

<div id="mouseAssistance"><span></span><span></span><span></span><span></span></div>

<script type="text/javascript">
"use strict";

const defaultFileNameList = ['

if (( $# != 0 )); then
  {
    if (( $sort == 1 )); then
      find "$@" "${dirs[@]}" -type f | sort -V
    else
      for d in "$@" "${dirs[@]}"; do
        find "$d" -type f | sort -V
      done
    fi
  } | sed '/\(Thumbs\.db\|\.directory|\.html\)$/d
  s/\\/\\\\/g
  s/"/\\"/g
  s/#/%23/g
  s/\?/%3F/g
  s/\&/%26/g
  s/^/"/
  s/$/",/'
fi

echo '];

let longJumpSearchImg = 10;
let longJumpSearchChap = 5;

const urlParams = new URLSearchParams(window.location.search);
const originalModeName = urlParams.get("mode");
urlParams.delete("mode");

let ifile = +urlParams.values().next().value || 0;
const img = document.getElementsByTagName("img")[0];
const info = document.getElementById("info");
const body = document.documentElement;

const min = Math.min;
const max = Math.max;

let fileByFilename;
let filenames;
let nbFilename;
// chapterByIndexes: [{startIndex: from filenames, images: [filename...], ichap: Number}...]
// chapterByIndexes.length == nbFilename
let chapterByIndexes;
let startIndexByChapters;

const rotate = function(deg) {
  const r = img.getAttribute("style");
  if (r) {
    deg += Number(r.substring(25, r.length-4));
  }
  img.setAttribute("style", `transform:rotate(${deg}deg)`);
};

const openInNewTab = function(type) {
  mode.syncIFile();
  const url = filenames[ifile];
  if (type === 2) {
    window.open(url, url);
  }
  else {
    const a = document.createElement("a");
    a.href = url;
    document.body.appendChild(a);
    disableShortcuts();
    if (type === 0) {
      a.dispatchEvent(new MouseEvent("click", {ctrlKey: true}));
    }
    else {
      a.target = "_blank";
      a.dispatchEvent(new MouseEvent("click"));
    }
    enableShortcuts();
    document.body.removeChild(a);
  }
};

const toBottomOnLoad = function(image) {
  image.onload = function(e) {
    body.scrollTop = image.clientHeight;
    image.onload = undefined;
  };
};

const scrollOnImageAfterDelay = function(image, delay, addTop) {
  let trigger = false;

  const timerId = setTimeout(function() {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      image.onload = undefined;
    }
    else {
      trigger = true;
    }
  }, delay);

  image.onload = function(e) {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      clearInterval(timerId);
    }
    else {
      trigger = true;
    }
    image.onload = undefined;
  };
};

const isLocalProtocol = (location.protocol === "file:");

const setImage = (function(){
  if (isLocalProtocol) {
    return function(img, filename) {
      img.src = filename;
    };
  }

  return function(img, filename) {
    if (fileByFilename) {
      const reader = new FileReader();
      reader.onload = (e) => {
        img.src = e.target.result;
      };
      reader.readAsDataURL(fileByFilename[filename]);
    }
    else {
      img.src = filename;
    }
  };
})();

const normalMode = {
  start: function() {
    setImage(img, filenames[ifile]);
  },
  stop: function() {},
  next: function() {
    if (ifile !== nbFilename) {
      setImage(img, filenames[++ifile]);
      body.scrollTop = 0;
    }
  },
  prev: function() {
    if (ifile) {
      setImage(img, filenames[--ifile]);
      toBottomOnLoad(img);
    }
  },
  advance: function(x) {
    ifile = max(0, min(ifile+x, nbFilename-1));
    setImage(img, filenames[ifile]);
    body.scrollTop = 0;
  },
  advanceChap: function(x) {
    const chap = chapterByIndexes[ifile];
    const ichap = max(0, min(chap.ichap + x, startIndexByChapters.length-1));
    ifile = startIndexByChapters[ichap];
    // when last chapter, go to end image
    if (x > 0 && ichap === chap.ichap) {
      ifile += chap.images.length - 1;
    }
    setImage(img, filenames[ifile]);
    body.scrollTop = 0;
  },
  syncIFile: function() {},
};

const doublePageMode = {
  start: function() {
    this.db = false;
  },
  stop: function() {},
  next: function() {
    if (this.dp) {
      if (ifile === nbFilename) {
        return;
      }
      setImage(img, filenames[++ifile]);
    }
    this.dp = !this.dp;
    body.scrollTop = 0;
  },
  prev: function() {
    if (this.dp) {
      if (!ifile) {
        return;
      }
      setImage(img, filenames[--ifile]);
      toBottomOnLoad(img);
    }
    else {
      body.scrollTop = img.clientHeight;
    }
    this.dp = !this.dp;
  },
  advance: function(x) {
    this.db = false;
    normalMode.advance(x);
  },
  advanceChap: function(x) {
    this.db = false;
    normalMode.advanceChap(x);
  },
  syncIFile: function() {},
};

const isSinglePageImg = function() {
  return img.width <= img.height;
};

const normalOrDoublePageMode = {
  start: function() {
    doublePageMode.start();
  },
  stop: function() {},
  next: function() {
    if (isSinglePageImg()) {
      normalMode.next();
    }
    else {
      doublePageMode.next();
    }
  },
  prev: function() {
    if (isSinglePageImg()) {
      normalMode.prev();
    }
    else {
      doublePageMode.prev();
    }
  },
  advance: function(x) {
    doublePageMode.advance(x);
  },
  advanceChap: function(x) {
    doublePageMode.advanceChap(x);
  },
  syncIFile: function() {},
};

const appendImages = function(elem, urls, startIndex) {
  const nUrl = urls.length;
  for (let i = 0; i < nUrl; ++i) {
    const img = document.createElement("img");
    setImage(img, urls[i]);
    img.dataset.i = i + startIndex;
    elem.appendChild(img);
  }
};

const removeChildren = function(elem) {
  while (elem.lastChild) {
    elem.lastChild.remove();
  }
}

const groupPageModeBase = {
  eimgs: (function(){
    const div = document.createElement("div");
    div.className = "imgWrapper";
    return div;
  })(),
  syncIFile: function() {
    const img = document.elementFromPoint(body.clientWidth / 2, 10);
    const i = img.dataset.i;
    if (i) {
      ifile = +i;
    }
  },
  _start: function(chapterByIndexes, startIndexByChapters, imageLimit) {
    if (0 === filenames.length) {
      return;
    }

    if (!imageLimit) {
      this.chapterByIndexes = chapterByIndexes;
    }
    else if (imageLimit in this.chapterByIndexesByImageLimits) {
      this.chapterByIndexes = this.chapterByIndexesByImageLimits[imageLimit];
    }
    else {
      const chaps = new Array(filenames.length);
      let startIndex = 0;
      for (const chapIndex of startIndexByChapters) {
        const images = chapterByIndexes[chapIndex].images;
        const imageLen = images.length;
        if (imageLen > imageLimit) {
          for (let i = 0; i < imageLen; i += imageLimit) {
            const subImages = images.slice(i, i + imageLimit);
            const subImageLen = subImages.length;
            chaps.fill({startIndex, images: subImages}, startIndex, startIndex + subImageLen);
            startIndex += subImageLen;
          }
        }
        else {
          chaps.fill({startIndex, images}, startIndex, startIndex + imageLen);
          startIndex += imageLen;
        }
      }
      this.chapterByIndexesByImageLimits[imageLimit] = chaps;
      this.chapterByIndexes = chaps;
    }

    document.body.removeChild(img);
    document.body.appendChild(this.eimgs);
    this.updateChapter();
    const i = this.currentChapter.startIndex;
    const image = this.eimgs.childNodes[ifile-i];
    // TODO calculate the scroll in relation to the position of the image
    scrollOnImageAfterDelay(image, 100, 0);
  },
  updateChapter: function(){
    const chap = this.chapterByIndexes[ifile];
    this.currentChapter = chap;
    removeChildren(this.eimgs);
    appendImages(this.eimgs, chap.images, chap.startIndex);
  },
  stop: function() {
    if (0 === filenames.length) {
      return;
    }
    this.syncIFile();
    setImage(img, filenames[ifile]);
    document.body.removeChild(this.eimgs);
    document.body.appendChild(img);
    // TODO calculate the scroll in relation to the position of the image
    body.scrollTop = 0;
  },
  next: function() {
    const i = this.currentChapter.startIndex + this.currentChapter.images.length;
    if (i !== nbFilename) {
      ifile = i;
      this.updateChapter();
      body.scrollTop = 0;
    }
  },
  prev: function() {
    if (this.currentChapter.startIndex) {
      ifile = this.currentChapter.startIndex - 1;
      this.updateChapter();
      const image = this.eimgs.lastChild;
      scrollOnImageAfterDelay(image, 100, 100);
    }
  },
  advance: function(x) {
    this.syncIFile();
    ifile = max(0, min(ifile+x, nbFilename-1));
    const chap = this.chapterByIndexes[ifile];
    if (this.currentChapter === chap) {
      body.scrollTop = this.eimgs.children[ifile - chap.startIndex].offsetTop;
    }
    else {
      body.scrollTop = 0;
      this.currentChapter = chap;
      removeChildren(this.eimgs);
      appendImages(this.eimgs, chap.images, chap.startIndex);
      const image = this.eimgs.childNodes[ifile-chap.startIndex];
      scrollOnImageAfterDelay(image, 100, 0);
    }
  },
  advanceChap: function(x) {
    this.syncIFile();
    let chap = chapterByIndexes[this.chapterByIndexes[ifile].startIndex];
    const prevIChap = chap.ichap;
    const ichap = max(0, min(prevIChap + x, startIndexByChapters.length-1));
    ifile = startIndexByChapters[ichap];
    // when last chapter, go to end image
    if (x > 0 && ichap === prevIChap) {
      ifile += chap.images.length - 1;
    }
    chap = this.chapterByIndexes[ifile];
    body.scrollTop = 0;
    this.currentChapter = chap;
    removeChildren(this.eimgs);
    appendImages(this.eimgs, chap.images, chap.startIndex);
    const image = this.eimgs.childNodes[ifile-chap.startIndex];
    scrollOnImageAfterDelay(image, 100, 0);
  },
};

const webtoonMode = Object.assign({
  chapterByIndexesByImageLimits: {},
  start: function(imageLimit) {
    this._start(chapterByIndexes, startIndexByChapters, imageLimit);
  },
}, groupPageModeBase);

const allMode = Object.assign({
  chapterByIndexesByImageLimits: {},
  start: function(imageLimit) {
    this._start([{startIndex: 0, images: filenames}], [0], imageLimit);
  },
}, groupPageModeBase);

const modeToModeName = function(mode) {
  switch (mode) {
    case normalMode: return "normal";
    case doublePageMode: return "double";
    case webtoonMode: return "webtoon";
    case normalOrDoublePageMode: return "normal_or_double";
    case allMode: return "all";
  }
}

const modeNameToMode = function(name) {
  switch (name) {
    case "normal": return normalMode;
    case "double": return doublePageMode;
    case "webtoon": return webtoonMode;
    case "normal_or_double": return normalOrDoublePageMode;
    case "all": return allMode;
  }
}

let mode = modeNameToMode(originalModeName) || normalMode;
let currentImageLimit = 0;
let bottomPixelDistance = 20;

const downOrNext = function(d, height) {
  if (body.scrollTop + body.clientHeight >= body.scrollHeight - d) {
    mode.next();
  }
  else {
    body.scrollTop += height || body.clientHeight;
  }
};

const upOrPrev = function(height) {
  if (body.scrollTop === 0) {
    mode.prev();
  }
  else {
    body.scrollTop -= height || body.clientHeight;
  }
};

// auto-scroll
//@{
let autoScrollDelay = null;
let autoScrollTimerId = null;

const startAutoScroll = function(delay) {
  console.log(`delay: ${delay}`);
  clearInterval(autoScrollTimerId);
  autoScrollDelay = delay;
  autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
};

const toggleAutoScroll = function(delay) {
  if (autoScrollDelay === null) {
    startAutoScroll(delay);
  }
  else if (autoScrollTimerId === null) {
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  else {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = null;
  }
};

const addAutoScrollInterval = function(delay) {
  autoScrollDelay = max(1, (autoScrollDelay || 800) + delay);
  if (autoScrollTimerId !== null) {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  console.log(`autoScrollDelay: ${autoScrollDelay} (+${delay})`);
};
//@}

const closeEvent = {key: "Escape"};
const isCloseEvent = (e) => e.key === "Escape";

const osd = (function() {
  let resumeAutoScroll = false;
  let isClosable;
  let closeAction;
  const forceCloseOSD = function(ev) {
    window.removeEventListener("keydown", removeOSD, true);
    if (resumeAutoScroll) {
      resumeAutoScroll = false;
      if (autoScrollTimerId === null) {
        autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
      }
    }
    closeAction(ev);
  };
  const removeOSD = function(ev) {
    if (isClosable(ev)) {
      forceCloseOSD(ev);
    }
  };
  const open = function(isClosableFn, closeActionFn) {
    if (autoScrollTimerId !== null) {
      clearInterval(autoScrollTimerId);
      autoScrollTimerId = null;
      resumeAutoScroll = true;
    }

    isClosable = isClosableFn;
    closeAction = closeActionFn;
    window.addEventListener("keydown", removeOSD, true);
  }
  open.close = forceCloseOSD;
  return open;
})();

const showImageInfo = function() {
  mode.syncIFile();
  const chap = chapterByIndexes[ifile];
  const scrollInfo = (autoScrollTimerId !== null) ? `[auto-scroll: ${autoScrollDelay}ms]` : "";
  info.textContent = `[${ifile+1}/${nbFilename}][Chapter: \
${chap.ichap+1}/${startIndexByChapters.length}][Img: ${ifile-chap.startIndex+1}/${chap.images.length}]${scrollInfo} \
${filenames[ifile]}`;
  info.style.display = "block";
  info.style.top = `${body.scrollTop}px`;
  disableShortcuts();
  osd(() => true, () => {
    enableShortcuts();
    info.style.display = "none";
  });
};

const showGoto = (function() {
  const goto = document.getElementById("goto");
  const gotoForm = document.getElementById("gotoForm");
  const gotoCancel = document.getElementById("gotoCancel");
  const gotoImageInput = document.getElementById("gotoImage");
  const gotoChapterInput = document.getElementById("gotoChapter");
  const gotoImageMax = document.getElementById("gotoImageMax");
  const gotoChapterMax = document.getElementById("gotoChapterMax");
  const gotoImageInChapter = document.getElementById("gotoImageInChapter");
  const gotoNameOfChapter = document.getElementById("gotoNameOfChapter");

  let lastInput = gotoImageInput;

  const validateGoto = function(e, input) {
    e.preventDefault();
    e.stopImmediatePropagation();

    lastInput = input;
    const n = input.value - 1;
    if (input === gotoImageInput) {
      mode.advance(n - ifile);
    }
    else {
      mode.advanceChap(n - chapterByIndexes[ifile].ichap);
    }
    osd.close(closeEvent);
  };

  gotoForm.addEventListener("submit", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    let elem = document.activeElement;
    if (elem !== gotoImageInput && elem !== gotoChapterInput) {
      elem = lastInput;
    }
    validateGoto(e, lastInput);
  }, false);

  gotoCancel.addEventListener("click", function(e) {
    validateGoto(e, lastInput);
  }, false);

  let chapStartIndex;

  const updateLastInput = function(e) {
    lastInput = e.target;
    e.preventDefault();
    e.stopImmediatePropagation();
  };

  const updateChapElement = function() {
    let filename = filenames[chapStartIndex];

    const index = filename.lastIndexOf("/");
    if (index !== -1) {
      filename = filename.substring(0, index);
    }
    gotoNameOfChapter.textContent = `(dirname: ${filename})`;
  };

  const updateImageElement = function() {
    const n = +gotoImageInput.value;
    const currentChap = chapterByIndexes[n-1];
    const startIndex = currentChap.startIndex;

    gotoImageInChapter.textContent = `(in the chapter: ${n-startIndex}/${currentChap.images.length})`;

    return startIndex;
  };

  gotoImageInput.addEventListener("change", function(e) {
    updateLastInput(e);
    const startIndex = updateImageElement();
    if (startIndex !== chapStartIndex) {
      chapStartIndex = startIndex;
      gotoChapterInput.value = chapterByIndexes[startIndex].ichap+1;
      updateChapElement();
    }
  });
  gotoChapterInput.addEventListener("change", function(e) {
    chapStartIndex = startIndexByChapters[gotoChapterInput.value-1];
    updateLastInput(e);
    updateChapElement();
    updateImageElement();
    gotoImageInput.value = chapterByIndexes[chapStartIndex].startIndex + 1;
  });

  return function() {
    const chap = chapterByIndexes[ifile];
    chapStartIndex = chap.startIndex;
    gotoImageInput.max = nbFilename;
    gotoImageInput.value = ifile+1;
    gotoChapterInput.value = chap.ichap+1;
    gotoChapterInput.max = startIndexByChapters.length;
    gotoImageMax.textContent = nbFilename;
    gotoChapterMax.textContent = startIndexByChapters.length;
    updateImageElement();
    updateChapElement();
    goto.style.display = "block";
    goto.style.top = `${body.scrollTop}px`;
    lastInput.focus();
    disableShortcuts();
    osd(isCloseEvent, function() {
      goto.style.display = "none";
      enableShortcuts();
      gotoImageInput.blur();
      gotoChapterInput.blur();
    });
  };
})();

const gotoImage = function(i) {
  if (i < 0) {
    i += nbFilename;
  }
  mode.advance(i - ifile);
};

const modal = function(isClosableFn, closeActionFn) {
  const img = document.getElementsByClassName("imgWrapper")[0];
  const display = img.style.display;
  const scrollTop = body.scrollTop;
  body.scrollTop = 0;
  img.style.display = "none";
  disableShortcuts();
  osd(isClosableFn, function(){
    img.style.display = display;
    body.scrollTop = scrollTop;
    enableShortcuts();
    closeActionFn();
  });
};
modal.close = osd.close;

const showShorcuts = (function() {
  const shortcutsDesc = document.getElementById("shortcuts");
  return function() {
    modal((e) => {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "PageDown":
        case "PageUp":
        case "Home":
        case "End":
        case "Ctrl":
        case "OS":
        case "Control":
        case "Shift":
        case "Alt":
        case "AltGraph":
        case " ":
        // browser search shortcut
        case "/":
        case "f"/* + ctrl */:
        case "F3":
        // fullscreen
        case "F11":
        // dev
        case "F12":
          return false;
      }
      return true;
    }, () => {
      shortcutsDesc.style.display = "none";
    });
    shortcutsDesc.style.display = "block";
  }
})();

const showLoader = (function() {
  const loader = document.getElementById("loader");
  const closeLoader = document.getElementById("closeLoader");
  const loaderForm = document.getElementById("loaderForm");
  const prefixLabel = document.getElementById("prefixLabel");
  const prefixElement = document.getElementById("prefix");
  const dirsElement = document.getElementById("dirs");
  const pathElement = document.getElementById("finalpath");
  const modes = {
    normal: document.getElementById("mode_normal"),
    double: document.getElementById("mode_double"),
    webtoon: document.getElementById("mode_webtoon"),
    normal_or_double: document.getElementById("mode_normal_or_double"),
    all: document.getElementById("mode_all"),
  }
  const regSplit = /([0-9]+(?:\.[0-9]+)?|[^0-9]+)/g;
  const regDigit = /^[0-9]/;

  const getPrefix = function() {
    let prefix = prefixElement.value;
    if (prefix && !prefix.endsWith("/")) {
      prefix += "/";
    }
    return prefix;
  };

  const updateFinalPath = function() {
    const file = dirsElement.files[0];
    if (file) {
      const path = document.createElement("b");
      path.textContent = getPrefix() + file.webkitRelativePath;
      pathElement.textContent = "Final path of one of the files: ";
      pathElement.appendChild(path);
    }
  };

  dirsElement.addEventListener("change", updateFinalPath, true);
  prefixElement.addEventListener("keyup", updateFinalPath, true);
  prefixElement.addEventListener("input", function(e) {
    // update only when pasted from clipboard
    if (e.inputType === "insertFromPaste") updateFinalPath();
  }, true);

  loaderForm.addEventListener("submit", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();

    const files = dirsElement.files;

    let newMode;
    for (const modeName in modes) {
      if (modes[modeName].checked) {
        const selectedMode = modeNameToMode(modeName);
        if (selectedMode !== mode) {
          mode.stop();
          newMode = selectedMode;
          mode = newMode;
        }
        break;
      }
    }

    const filenameDatas = [];
    for (const file of files) {
      const parts = [];
      const path = file.webkitRelativePath;
      // split by string and number
      for (const m of path.matchAll(regSplit)) {
        parts.push(regDigit.test(m[0]) ? Number(m[0]) : m[0]);
      }
      filenameDatas.push([path, parts, file]);
    }

    // natural sort
    filenameDatas.sort(function(a, b) {
      a = a[1];
      b = b[1];
      const alen = a.length;
      const blen = b.length;
      if (alen < blen) return -1;
      if (alen > blen) return 1;
      for (let i = 0; i < alen; ++i) {
        const x = a[i];
        const y = b[i];
        if (x < y) return -1;
        if (x > y) return 1;
      }
      return 0;
    });

    if (isLocalProtocol) {
      const prefix = getPrefix();
      if (localStorage) {
        localStorage.setItem("prefix", prefix);
      }

      const filenameLength = filenameDatas.length;
      for (let i = 0; i < filenameLength; ++i) {
        filenameDatas[i] = prefix + filenameDatas[i][0];
      }

      initFilenames(filenameDatas);
    }
    else {
      const filenameLength = filenameDatas.length;
      const filenames = new Array(filenameLength);
      const fileByFilename = {};
      for (let i = 0; i < filenameLength; ++i) {
        filenames[i] = filenameDatas[i][0];
        fileByFilename[filenames[i]] = filenameDatas[i][2];
      }

      initFilenames(filenames, fileByFilename);
    }

    if (newMode) {
      updateShortcuts(mode);
    }

    modal.close(closeEvent);
    body.scrollTop = 0;
  }, true);

  closeLoader.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    modal.close(closeEvent);
  }, true);

  return function() {
    modal(isCloseEvent, () => {
      loader.style.display = "none";
      prefixElement.blur();
    });
    prefixLabel.style.display = isLocalProtocol ? "inline" : "none";
    pathElement.style.display = isLocalProtocol ? "block" : "none";
    loader.style.display = "block";
    if (isLocalProtocol) {
      prefixElement.value = (localStorage && localStorage.getItem("prefix")) || "";
      updateFinalPath();
      prefixElement.focus();
    }
    modes[modeToModeName(mode)].checked = true;
  }
})();

const SEARCH_BY_CHAPTER         = 0b0000_000_000_000_001;
const SEARCH_BY_IMAGE           = 0b0000_000_000_000_010;
const SEARCH_BY_IMAGE_IN_CHAP   = 0b0000_000_000_000_100;
const SEARCH_BY_MASK            = 0b0000_000_000_000_111;

const SEARCH_THEN_BY_IMAGE      = 0b0000_000_000_001_000;
const SEARCH_THEN_BY_MASK       = 0b0000_000_000_001_000;

const SEARCH_CASE_SENSITIVE     = 0b000_000_001_000_000;
const SEARCH_CASE_INSENSITIVE   = 0b000_000_010_000_000;
const SEARCH_UPPERCASE_ONLY     = 0b000_000_100_000_000;
const SEARCH_CASE_SENSITIVITY_MASK = 0b0000_000_111_000_000;

const SEARCH_ACCENT_SENSITIVE   = 0b0000_001_000_000_000;
const SEARCH_ACCENT_INSENSITIVE = 0b0000_010_000_000_000;
const SEARCH_ACCENT_ONLY        = 0b0000_100_000_000_000;
const SEARCH_ACCENT_SENSITIVITY_MASK = 0b0000_111_000_000_000;

const SEARCH_MODE_WORD          = 0b0001_000_000_000_000;
const SEARCH_MODE_FUZZY         = 0b0010_000_000_000_000;
const SEARCH_MODE_TEXT          = 0b0100_000_000_000_000;
const SEARCH_MODE_REGEX         = 0b1000_000_000_000_000;
const SEARCH_MODE_MASK          = 0b1111_000_000_000_000;

const showSearcher = (function() {
  // Testable searcher
  // @{

  const removeAccents = function(str) {
    // remove diacritics
    return str.normalize("NFD").replace(/\p{Mn}/gu, "");
  };

  const escapeRegex = function(str) {
    return str.replace(/[\\^$()\[\{?*+.]/g, (m) => "\\" + m);
  };

  const optionsToPatternAndStrKey = function(options, pattern) {
    switch (options & (SEARCH_CASE_SENSITIVITY_MASK | SEARCH_ACCENT_SENSITIVITY_MASK)) {
      case SEARCH_CASE_SENSITIVE   | SEARCH_ACCENT_SENSITIVE:
        return [pattern, "str"];
      case SEARCH_CASE_SENSITIVE   | SEARCH_ACCENT_INSENSITIVE:
        return [removeAccents(pattern), "unaccentedStr"];
      case SEARCH_CASE_INSENSITIVE | SEARCH_ACCENT_SENSITIVE:
        return [pattern.toUpperCase(), "upperStr"];
      case SEARCH_CASE_INSENSITIVE | SEARCH_ACCENT_INSENSITIVE:
        return [removeAccents(pattern.toUpperCase()), "unaccentedUpperStr"];
    }
  };

  const createFuzzySearcher = function(options, c) {
    if (options & SEARCH_UPPERCASE_ONLY) {
      const upper = c.toUpperCase();
      options &= ~SEARCH_CASE_SENSITIVITY_MASK;
      options |= (upper === c) ? SEARCH_CASE_SENSITIVE : SEARCH_CASE_INSENSITIVE;
    }

    if (options & SEARCH_ACCENT_ONLY) {
      const accent = removeAccents(c);
      options &= ~SEARCH_ACCENT_SENSITIVITY_MASK;
      options |= (accent === c) ? SEARCH_ACCENT_INSENSITIVE : SEARCH_ACCENT_SENSITIVE;
    }

    const [pattern, strKey] = optionsToPatternAndStrKey(options, c);
    return (si) => {
      si.length = 1;
      return si[strKey].indexOf(pattern, si.index+1);
    };
  };

  const createTextSearcher = function(options, str, afterLastIndex) {
    if ((options & (SEARCH_UPPERCASE_ONLY | SEARCH_ACCENT_ONLY)) === 0) {
      const [pattern, strKey] = optionsToPatternAndStrKey(options, str);
      return (si) => {
        const index = si.index + (afterLastIndex ? si.length : 0);
        si.length = pattern.length;
        return si[strKey].indexOf(pattern, index);
      }
    }

    const flags = (options & SEARCH_CASE_INSENSITIVE) ? "gi" : "g";
    let regex;
    let strKey = "nfdStr";

    if (options & SEARCH_ACCENT_ONLY) {
      // optional accent for each letter
      const toReg = (options & SEARCH_UPPERCASE_ONLY)
        ? (m) => (m === m.toUpperCase() ? m : `[${m}${m.toUpperCase()}]`) + "\\p{Mn}?"
        : (m) => m + "\\p{Mn}?";

      let pattern = "";
      for (const m of escapeRegex(str.normalize("NFD"))
        // Mn => Nonspacing_Mark (contains accents only?)
        .matchAll(/([^\p{Mn}]+)[\p{Mn}]?|[\p{Mn}]/gu)
      ) {
        const reg = m[1];
        const accent = m[0].substr(reg.length);
        pattern += reg.replace(/\p{L}/gu, toReg) + m[0].substr(reg.length);
      }

      regex = new RegExp(pattern, flags + "u");
    }
    else {
      const pattern = escapeRegex(str)
        // lower letter as lower and upper letter
        .replace(/\p{Ll}/gu, (m) => `[${m}${m.toUpperCase()}]`);

      const insensitiveAccent = (options & SEARCH_ACCENT_INSENSITIVE);
      regex = new RegExp(insensitiveAccent ? removeAccents(pattern) : pattern, flags);
      strKey = insensitiveAccent ? "unaccentedStr" : "str";
    }

    return (si) => {
      regex.lastIndex = si.index + (afterLastIndex ? si.length : 0);
      const m = regex.exec(si[strKey]);
      if (m) {
        si.length = m[0].length;
        return m.index;
      }
      return -1;
    };
  };

  const searchRegIndex = function(str, si, reg) {
    const m = str.match(reg);
    if (m) {
      si.length = m[0].length;
      return m.index;
    }
    return -1;
  };

  const createRegexSearcher = function(options, pattern) {
    const isCaseInsensitive = options & (SEARCH_UPPERCASE_ONLY | SEARCH_CASE_INSENSITIVE);
    const isAccentInsensitive = options & (SEARCH_ACCENT_ONLY | SEARCH_ACCENT_INSENSITIVE);

    const regex = new RegExp(isAccentInsensitive ? removeAccents(pattern) : pattern,
                             isCaseInsensitive ? "i" : "");
    return isAccentInsensitive
      ? (si) => searchRegIndex(si.unaccentedStr, si, regex)
      : (si) => searchRegIndex(si.str, si, regex);
  };

  const filter = function(datas, searcher) {
    let newLength = 0;
    for (const si of datas) {
      const index = searcher(si);
      if (index !== -1) {
        si.index = index;
        si.fragments.push({index, length: si.length});
        datas[newLength] = si;
        ++newLength;
      }
    }
    datas.length = newLength;
  };

  // @}

  const searcherElement = document.getElementById("searcher");
  const input = document.getElementById("searchInputMode");
  const searchInputErrorElement = document.getElementById("searchInputError");
  const searchByElement = document.getElementById("searchBy");
  const searchThenByElement = document.getElementById("searchThenBy");
  const searchCaseSensitivityElement = document.getElementById("searchCaseSensitivity");
  const searchAccentSensitivityElement = document.getElementById("searchAccentSensitivity");
  const searchModeElement = document.getElementById("searchMode");
  const searchCloseElement = document.getElementById("searchClose");
  const searchResultListElement = document.getElementById("searchResultList");

  let strings;
  let results;
  let previousText;
  let previousWordIndex;
  let activeElement;
  let options;
  let unaccentedStrCaches;
  let upperStrCaches;
  let unaccentedUpperStrCaches;
  let nfdStrCaches;
  let icache = 0;

  const resetState = function() {
    // state for updateResults()
    previousText = "";
    previousWordIndex = 0;

    removeChildren(searchResultListElement);
    const len = strings.length;
    const unaccentedStrs = unaccentedStrCaches[icache];
    const upperStrs = upperStrCaches[icache];
    const unaccentedUpperStrs = unaccentedUpperStrCaches[icache];
    const nfdStrs = nfdStrCaches[icache];

    // create results and DOM elements
    results = new Array(len);
    const previousMatch = (options & SEARCH_MODE_WORD) ? {index:0, lastIndex:0} : 0;
    for (let i = 0; i < len; ++i) {
      const str = strings[i];
      const elem = searchResultListElement.appendChild(document.createElement("a"));
      elem.appendChild(document.createTextNode(str));
      elem.setAttribute("href", "#");
      elem.dataset.index = i;
      results[i] = {
        str,
        upperStr: upperStrs[i],
        unaccentedStr: unaccentedStrs[i],
        unaccentedUpperStr: unaccentedUpperStrs[i],
        nfdStr: nfdStrs[i],
        index: 0,
        length: 0,
        previousMatch: previousMatch,
        elem,
        fragments: [],
      };
    }
  };

  const setActiveSearch = function(i) {
    if (activeElement) {
      activeElement.removeAttribute("id");
    }
    activeElement = results[i].elem;
    activeElement.setAttribute("id", "activeSearch");
    updateResultScroll();
  }

  const userActiveIndex = function() {
    return (options & SEARCH_BY_CHAPTER) ? chapterByIndexes[ifile].ichap : ifile;
  };

  const getDisplayStrKey = function(mode) {
    mode |= SEARCH_ACCENT_ONLY;
    return (options & mode === mode) ? "nfdStr" : "str";
  }

  // merge fragments [idx: 1, len:1][idx: 2, len:1] = [idx: 1, len:2]
  const mergeFragments = function(fragments) {
    const fragLen = fragments.length;
    let prev = fragments[0];
    let newFragLen = 1;
    for (let i = 1; i < fragLen; ++i) {
      const fragment = fragments[i];
      if (prev.index + prev.length === fragment.index) {
        prev.length += fragment.length;
      }
      else {
        fragments[newFragLen] = fragment;
        prev = fragment;
        ++newFragLen;
      }
    }
    return newFragLen;
  };

  const updateFuzzyDisplay = function() {
    removeChildren(searchResultListElement);

    for (const result of results) {
      const fragments = result.fragments;
      result.fragments = [];

      const fragLen = mergeFragments(fragments);
      const str = result.str;
      const elem = result.elem;

      let i = 0
      let lastIndex = result.previousMatch;

      // remove text element
      elem.lastChild.remove();
      let lastElem = elem.lastChild;
      if (lastElem) {
        const fragment = fragments[0];
        const index = fragment.index;
        // append to last <b>
        if (index === lastIndex) {
          lastIndex += fragment.length;
          const textContent = str.substring(index, lastIndex);
          lastElem.firstChild.textContent += textContent;
          ++i;
        }
      }

      for (; i < fragLen; ++i) {
        const fragment = fragments[i];
        const index = fragment.index;
        elem.appendChild(document.createTextNode(str.substring(lastIndex, index)));
        lastIndex = index + fragment.length;
        const textContent = str.substring(index, lastIndex);
        const b = elem.appendChild(document.createElement("b"));
        b.textContent = textContent;
      }

      // add final unmatch text
      if (lastIndex !== str.length) {
        elem.appendChild(document.createTextNode(str.substring(lastIndex)));
      }

      result.previousMatch = lastIndex;
      searchResultListElement.appendChild(elem);
    }
  };

  const updateFragmentsDisplay = function(removeLastMatch) {
    const strKey = getDisplayStrKey(SEARCH_MODE_WORD);

    removeChildren(searchResultListElement);

    for (const result of results) {
      const fragments = result.fragments;
      result.fragments = [];

      const fragLen = mergeFragments(fragments);
      const str = result[strKey];
      const elem = result.elem;

      let previousIndex = result.previousMatch.index;

      // (1)  [TEXT]                   (first call)
      // (2)  [TEXT][Fragment]         (impossible)
      // (3)        [Fragment]         (impossible)
      // (4)        [Fragment][TEXT]
      // (5)  [TEXT][Fragment][TEXT]
      elem.lastChild.remove();
      let lastElem = elem.lastChild;
      if (removeLastMatch) {
        // (4) (5)
        if (lastElem) {
          // (5)
          if (lastElem.previousSibling) {
            lastElem.previousSibling.remove();
          }
          lastElem.remove();
        }
      }
      else if (lastElem) {
        previousIndex = result.previousMatch.lastIndex;
      }

      let lastIndex = previousIndex;
      let i = 0;

      while (true) {
        const fragment = fragments[i];
        const index = fragment.index;
        elem.appendChild(document.createTextNode(str.substring(lastIndex, index)));
        lastIndex = index + fragment.length;
        const textContent = str.substring(index, lastIndex);
        const b = elem.appendChild(document.createElement("b"));
        b.textContent = textContent;

        if (++i === fragLen) {
          break;
        }
        previousIndex = lastIndex;
      }

      // add final unmatch text
      if (lastIndex !== str.length) {
        elem.appendChild(document.createTextNode(str.substring(lastIndex)));
      }

      result.previousMatch = {index: previousIndex, lastIndex: lastIndex};

      searchResultListElement.appendChild(elem);
    }
  };

  const updateRangeDisplay = function() {
    const strKey = getDisplayStrKey(SEARCH_MODE_TEXT);
    removeChildren(searchResultListElement);
    for (const result of results) {
      const elem = result.elem;
      const str = result[strKey];
      const index = result.index;
      const len = result.length;
      removeChildren(elem);
      elem.appendChild(document.createTextNode(str.substr(0, index)));
      elem.appendChild(document.createElement("b")).textContent = str.substr(index, len);
      elem.appendChild(document.createTextNode(str.substr(index+len)));
      searchResultListElement.appendChild(elem);
    }
  };

  const updateResultScroll = function() {
    const firstElementChild = searchResultList.firstElementChild;
    if (!firstElementChild) {
      return;
    }
    const rect = activeElement.getBoundingClientRect();
    const outerRect = searchResultList.getBoundingClientRect();
    const firstRect = firstElementChild.getBoundingClientRect();
    searchResultList.scrollTop = rect.y - firstRect.y - outerRect.height / 2;
  };

  const updateResults = function() {
    const text = input.value;

    // if the character is not added at the end of the text (unoptimized case)
    if (!text.startsWith(previousText)) {
      const i = activeElement.parentNode ? activeElement.dataset.index : userActiveIndex();
      resetState();
      activeElement = results[i].elem;
      activeElement.setAttribute("id", "activeSearch");

      if (text.length === 0) {
        return;
      }
    }
    else if (text.length === previousText.length) {
      return;
    }

    switch (options & SEARCH_MODE_MASK) {
      case SEARCH_MODE_FUZZY:
        for (let i = previousText.length; i < text.length; ++i) {
          filter(results, createFuzzySearcher(options, text[i]));
        }
        updateFuzzyDisplay();
        break;

      case SEARCH_MODE_WORD:
        // ignore word separator
        if (text[previousText.length] === " ") {
          // consume spaces
          let i = previousText.length + 1;
          while (text[i] === " ") {
            ++i;
          }

          // contains only spaces
          if (i === text.length) {
            previousText = text;
            return;
          }
        }

        let iword = previousWordIndex;
        let removeLastMatch = true;
        // previous character is a word separator
        if (text[previousText.length - 1] === " ") {
          iword = previousText.length - 1;
          removeLastMatch = false;
        }
        let afterLastIndex = false;
        let update = false;

        while (true) {
          // consume spaces
          if (text[iword] === " ") {
            do {
              ++iword;
            } while (text[iword] === " ");

            if (iword >= text.length) {
              break;
            }
            previousWordIndex = iword;
            afterLastIndex = true;
          }

          update = true;
          const endIndex = text.indexOf(" ", iword);
          const word = text.substring(iword, (endIndex === -1) ? text.length : endIndex);
          filter(results, createTextSearcher(options, word, afterLastIndex));
          if (endIndex === -1) {
            break;
          }
          iword = endIndex;
        }

        if (!update) {
          previousText = text;
          return;
        }

        updateFragmentsDisplay(removeLastMatch);
        break;

      case SEARCH_MODE_TEXT:
        const pattern = text.substr(previous.length);
        filter(results, createTextSearcher(options, pattern));
        updateRangeDisplay();
        break;

      case SEARCH_MODE_REGEX:
        try {
          filter(results, createRegexSearcher(options, text));
        }
        catch (ex) {
          if (ex instanceof SyntaxError) {
            searchInputErrorElement.textContent = ex;
            searchInputErrorElement.style.display = "block";
            return;
          }
          throw ex;
        }
        searchInputErrorElement.style.display = "none";
        updateRangeDisplay();
        break;
    }

    previousText = text;

    // if activeElement is not in the DOM
    if (!activeElement.parentNode && results[0]) {
      activeElement = results[0].elem;
      activeElement.setAttribute("id", "activeSearch");
    }

    updateResultScroll();
  };


  searchCloseElement.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    modal.close(closeEvent);
  }, true);

  let savedIndex = null;
  const validateItem = function(i) {
    if (options & SEARCH_BY_IMAGE_IN_CHAP) {
      // /!\ i is a string
      i = (i|0) + savedIndex;
      savedIndex = null;
    }
    else if (options & SEARCH_BY_CHAPTER) {
      const startIndex = startIndexByChapters[i];
      if (savedIndex === null && (options & SEARCH_THEN_BY_IMAGE)) {
        input.value = "";
        activeElement = null;
        options |= SEARCH_BY_IMAGE_IN_CHAP;
        savedIndex = startIndex;
        initImageStringsOfChapIndex(startIndex);
        resetState();
        setActiveSearch(chapterByIndexes[ifile].startIndex === startIndex ? ifile - startIndex : 0);
        return;
      }
      i = startIndex;
    }
    mode.advance(i - ifile);
    modal.close(closeEvent);
  };

  input.addEventListener("keyup", updateResults, true);
  input.addEventListener("keydown", function(e) {
    switch (e.key) {
      case "ArrowUp":
      case "ArrowDown":
      case "PageUp":
      case "PageDown": {
        e.preventDefault();
        e.stopImmediatePropagation();

        if (results.length === 0) {
          return;
        }

        // if activeElement is in the DOM
        if (activeElement.parentNode) {
          const isUp = (e.key === "ArrowUp" || e.key === "PageUp");
          const step = (e.key === "PageUp" || e.key === "PageDown")
            ? ((options & SEARCH_BY_IMAGE) ? longJumpSearchImg : longJumpSearchChap)
            : 1;
          let next = activeElement;
          for (let i = 0; i < step; ++i) {
            next = isUp ? next.previousSibling : next.nextSibling;
            // circular list, go to top/bottom
            if (!next) {
              next = results[isUp ? results.length - 1 : 0].elem;
            }
          }
          activeElement.removeAttribute("id");
          activeElement = next;
        }
        else {
          activeElement = results[0].elem;
        }
        activeElement.setAttribute("id", "activeSearch");
        updateResultScroll();
        break;
      }

      // validate element
      case "Enter": {
        e.preventDefault();
        e.stopImmediatePropagation();

        let i;
        if (activeElement.parentNode) {
          i = activeElement.dataset.index;
        }
        else if (results.length !== 0) {
          i = results[0].elem.dataset.index;
        }
        else {
          return;
        }

        validateItem(i);
        break;
      }
    }
  }, true);

  input.addEventListener("input", function(e) {
    // update when pasted
    if (e.inputType === "insertFromPaste") {
      e.preventDefault();
      e.stopImmediatePropagation();
      updateResults();
    }
  }, true);

  searchResultListElement.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    let elem = e.target;
    if (elem.tagName === "B") {
      elem = elem.parentNode;
    }
    validateItem(elem.dataset.index);
  });

  const searchCommonPrefixLength = function(strings) {
    const firstString = strings[0];
    let prefixLen = firstString.lastIndexOf("/");

    if (prefixLen === -1) {
      return 0;
    }

    const len = strings.length;
    for (let i = 1; i < len && prefixLen !== 0; ++i) {
      const filename = strings[i];
      const len = min(prefixLen, filename.length);
      prefixLen = 0;
      while (prefixLen < len && filename[prefixLen] === firstString[prefixLen]) {
        ++prefixLen;
      }
    }

    const i = firstString.lastIndexOf("/", prefixLen);
    return (i !== -1) ? i + 1 : prefixLen;
  };

  let stringByChapters;
  let stringByImages;

  const initStrCaches = function() {
    // initialize string caches
    const len = strings.length;
    const unaccentedStrs = unaccentedStrCaches[icache] = new Array(len);
    const upperStrs = upperStrCaches[icache] = new Array(len);
    const unaccentedUpperStrs = unaccentedUpperStrCaches[icache] = new Array(len);
    const nfdStrs = nfdStrCaches[icache] = new Array(len);
    for (let i = 0; i < len; ++i) {
      const str = strings[i];
      unaccentedStrs[i] = removeAccents(str);
      upperStrs[i] = str.toUpperCase();
      unaccentedUpperStrs[i] = unaccentedStrs[i].toUpperCase();
      nfdStrs[i] = str.normalize("NFD");
    }
  }

  const initStrings = function() {
    strings = (options & SEARCH_BY_CHAPTER) ? stringByChapters : stringByImages;
    icache = (options & SEARCH_BY_CHAPTER) ? 0 : 1;
    if (strings) {
      return;
    }

    let stringRefs = filenames;
    let stringRefsLen = nbFilename;
    if (options & SEARCH_BY_CHAPTER) {
      stringRefsLen = startIndexByChapters.length;
      stringRefs = new Array(stringRefsLen);
      for (let i = 0; i < stringRefsLen; ++i) {
        const chapIndex = startIndexByChapters[i];
        const filename = filenames[chapIndex];
        const index = filename.lastIndexOf("/");
        stringRefs[i] = (index === -1) ? filename : filename.substr(0, index);
      }
    }

    const prefixLen = searchCommonPrefixLength(stringRefs);

    // create string list reference
    strings = new Array(stringRefsLen);
    for (let i = 0; i < stringRefsLen; ++i) {
      strings[i] = stringRefs[i].substr(prefixLen);
    }

    if (options & SEARCH_BY_CHAPTER) {
      stringByChapters = strings;
    }
    else {
      stringByImages = strings;
    }

    if (!unaccentedStrCaches[icache]) {
      initStrCaches();
    }
  };

  const updateStrings = function() {
    const oldStrings = strings;
    initStrings();
    if (oldStrings !== strings) {
      resetState();
      setActiveSearch(userActiveIndex());
      updateResults();
    }
  };

  const initImageStringsOfChapIndex = function(ichap) {
    const chap = chapterByIndexes[ichap];
    const images = chap.images;
    const length = images.length;
    strings = new Array(length);
    for (let i = 0; i < length; ++i) {
      const filename = images[i];
      const idx = filename.lastIndexOf("/");
      strings[i] = (idx === -1) ? filename : filename.substr(idx + 1);
    }
    icache = 2;
    initStrCaches();
  };

  let initOptionsLock = false;
  const updateOptionsEvent = function(ev, firstOption, mask) {
    ev.preventDefault();
    ev.stopImmediatePropagation();

    if (initOptionsLock) {
      return;
    }

    const oldOptions = options;
    options &= ~mask;
    options |= firstOption << ev.target.selectedIndex;
    if ((oldOptions ^ options) & ~SEARCH_THEN_BY_MASK) {
      resetState();
      setActiveSearch(activeElement?.dataset.index | 0);
      updateResults();
    }
  };

  searchThenByElement.addEventListener("change", (ev) => {
    ev.preventDefault();
    ev.stopImmediatePropagation();
    options &= ~SEARCH_THEN_BY_MASK;
    options |= ev.target.checked ? SEARCH_THEN_BY_IMAGE : 0;
  });
  searchCaseSensitivityElement.addEventListener("change", (ev) => {
    updateOptionsEvent(ev, SEARCH_CASE_SENSITIVE, SEARCH_CASE_SENSITIVITY_MASK);
  });
  searchAccentSensitivityElement.addEventListener("change", (ev) => {
    updateOptionsEvent(ev, SEARCH_ACCENT_SENSITIVE, SEARCH_ACCENT_SENSITIVITY_MASK);
  });
  searchModeElement.addEventListener("change", (ev) => {
    updateOptionsEvent(ev, SEARCH_MODE_WORD, SEARCH_MODE_MASK);
  });
  searchByElement.addEventListener("change", function(ev) {
    ev.preventDefault();
    ev.stopImmediatePropagation();
    options &= ~SEARCH_BY_MASK;
    options |= SEARCH_BY_CHAPTER << ev.target.selectedIndex;
    updateStrings();
  });

  const updateForm = function(options) {
    const setSelectedIndex = function(elem, firstOption, mask) {
      let opt = options & mask;
      let i = 0;
      while (firstOption < opt) {
        opt >>= 1;
        ++i;
      }
      elem.selectedIndex = i;
    };

    initOptionsLock = true;
    searchThenByElement.checked = options & SEARCH_THEN_BY_IMAGE;
    setSelectedIndex(searchBy, SEARCH_BY_CHAPTER, SEARCH_BY_MASK);
    setSelectedIndex(searchCaseSensitivityElement, SEARCH_CASE_SENSITIVE, SEARCH_CASE_SENSITIVITY_MASK);
    setSelectedIndex(searchAccentSensitivityElement, SEARCH_ACCENT_SENSITIVE, SEARCH_ACCENT_SENSITIVITY_MASK);
    setSelectedIndex(searchModeElement, SEARCH_MODE_WORD, SEARCH_MODE_MASK);
    initOptionsLock = false;
  };

  let firstCall = true;

  const searcher = function(userOptions) {
    if (firstCall) {
      firstCall = false;
      options = userOptions;
      updateForm(options);
      initStrings();
      resetState();
      setActiveSearch(userActiveIndex());
    }
    else {
      options &= ~SEARCH_BY_IMAGE_IN_CHAP;
      savedIndex = null;
      updateStrings();
    }

    modal(isCloseEvent, () => {
      searcherElement.style.display = "none";
      input.blur();
    });
    searcherElement.style.display = "flex";
    input.focus();
  };

  searcher.reset = function() {
    stringByChapters = null;
    stringByImages = null;
    options = 0;
    unaccentedStrCaches = [null, null, null];
    upperStrCaches = [null, null, null];
    unaccentedUpperStrCaches = [null, null, null];
    nfdStrCaches = [null, null, null];
  };
  searcher.reset();
  return searcher;
}());

// save and load
// @{
const savePosition = function() {
  localStorage.setItem("ifile", ifile);
  localStorage.setItem("modeName", modeToModeName(mode));
  localStorage.setItem("imageLimit", currentImageLimit);
};

const loadPosition = function() {
  const mode = modeNameToMode(localStorage.getItem("modeName"));
  if (!mode) {
    return
  }

  selectMode(mode, +localStorage.getItem("imageLimit"));

  // webtoon may take time to load images
  setTimeout(function() {
    mode.advance(localStorage.getItem("ifile") - ifile);
  }, 200);
};
// @}

const toggleMouseAssistance = (function() {
  const style = document.getElementById("mouseAssistance").style;
  let timerId = null;
  let enabled = false;

  const hideAssistance = function() {
    clearInterval(timerId);
    timerId = null;
    style.display = "none";
  };

  const showAssistance = function(e) {
    style.top = `${body.scrollTop}px`;
    style.display = "grid";
    clearInterval(timerId);
    timerId = setTimeout(hideAssistance, 200);
  };

  return function() {
    if (enabled) {
      enabled = false;
      window.removeEventListener("mousemove", showAssistance, true);
    }
    else {
      enabled = true;
      window.addEventListener("mousemove", showAssistance, true);
    }
  };
})();

const isInZone = function(e, zone) {
  const isTop = (e.clientY < window.innerHeight / 2);
  const isLeft = (e.clientX < window.innerWidth / 2);
  // top=1 bottom=2 left=4 right=8
  switch (zone) {
    case 1: return isTop;
    case 2: return !isTop;
    case 4: return isLeft;
    case 8: return !isLeft;
    case 5: return isTop && isLeft;
    case 9: return isTop && !isLeft;
    case 6: return !isTop && isLeft;
    case 10: return !isTop && !isLeft;
  }
};

const selectMode = function(newMode, imageLimit) {
  if (mode !== newMode || currentImageLimit !== imageLimit) {
    currentImageLimit = imageLimit;
    mode.stop();
    mode = newMode;
    mode.start(imageLimit);
    updateShortcuts(mode);
  }
};

const rgxClickName = /^click\d+$/
const createActions = function(shortcuts, actionsByKeys, actionsByClicks){
  actionsByKeys = actionsByKeys || {};
  actionsByClicks = actionsByClicks || [];

  for (const d of shortcuts) {
    let actionsByControls = actionsByKeys[d.key];
    if (!actionsByControls) {
      actionsByControls = {};
      actionsByKeys[d.key] = actionsByControls;
      if (rgxClickName.test(d.key)) {
        actionsByClicks[d.key.substr(5)] = actionsByControls
      }
    }
    actionsByControls[d.alt + (d.ctrl << 1) + (d.shift << 2) + (d.meta << 3) + (d.altgr << 4)] = d.action;
  }

  // if there is no conflict, assume assume that:
  // - Shift+Key = Key (ex. Shift+< = <)
  // - AltGr+Key = Key
  const res = [actionsByKeys, actionsByClicks];
  for (const actions of res) {
    for (const k in actions) {
      const actionsByControls = actions[k];
      for (const m in actionsByControls) {
        const withShift = m | 0b00100;
        const withAltgr = m | 0b10000;
        if (!actionsByControls[withShift]) {
          actionsByControls[withShift] = actionsByControls[m];
        }
        if (!actionsByControls[withAltgr]) {
          actionsByControls[withAltgr] = actionsByControls[m];
        }
        if (!actionsByControls[withShift | withAltgr]) {
          actionsByControls[withShift | withAltgr] = actionsByControls[m];
        }
      }
    }
  }

  return res;
};

// contains key and mouse actions
const [globalActionsByKeys, globalActionsByClicks] = createActions(['"${shortcuts[@]}"']);

const createModActions = function(shortcuts) {
  const actionsByKeys = {};
  for (const d in globalActionsByKeys) {
    actionsByKeys[d] = Object.assign({}, globalActionsByKeys[d]);
  }
  return createActions(shortcuts, actionsByKeys, Array.from(globalActionsByClicks));
};
'
for mode in "${!shortcuts_by_mode[@]}"; do
  echo "${mode}.shortcuts = createModActions([${shortcuts_by_mode[$mode]}]);"
done
echo '

let actionsByKeys = globalActionsByKeys;
let actionsByClicks = globalActionsByClicks;
let actionsForPrimaryClick = actionsByClicks[0];

const eventMask = function(e) {
  return e.altKey
      + (e.ctrlKey << 1)
      + (e.shiftKey << 2)
      + (e.metaKey << 3)
      + (e.getModifierState("AltGraph") << 4)
      ;
};

const keydownEvent = function(e) {
  const actions = actionsByKeys[e.key] || actionsByKeys[e.key.toLowerCase()];
  if (actions) {
    const action = actions[eventMask(e)];
    if (action) {
      e.preventDefault();
      e.stopImmediatePropagation();
      action();
      return false;
    }
  }
  return true;
};

const clickEvent = function(e) {
  const action = actionsForPrimaryClick[eventMask(e)];
  if (action) {
    e.preventDefault();
    e.stopImmediatePropagation();
    action();
    return false;
  }
  return true;
};

const auxClickEvent = function(e) {
  let actions = actionsByClicks[e.button];
  if (actions) {
    const action = actions[e.altKey + (e.ctrlKey << 1) + (e.shiftKey << 2) + (e.metaKey << 3)];
    if (action) {
      e.preventDefault();
      e.stopImmediatePropagation();
      action(e);
      return false;
    }
    return true;
  }
};

function updateShortcuts(mode) {
  window.removeEventListener("click", clickEvent, true);
  window.removeEventListener("auxclick", auxClickEvent, true);

  actionsByKeys = mode.shortcuts ? mode.shortcuts[0] : globalActionsByKeys;
  actionsByClicks = mode.shortcuts ? mode.shortcuts[1] : globalActionsByClicks;

  if (0 in actionsByClicks) {
    actionsForPrimaryClick = actionsByClicks[0];
    window.addEventListener("click", clickEvent, true);
  }

  if (actionsByClicks.length > 1) {
    window.addEventListener("auxclick", auxClickEvent, true);
  }
}

function enableShortcuts() {
  window.addEventListener("keydown", keydownEvent, true);
  updateShortcuts(mode);
}

function disableShortcuts() {
  window.removeEventListener("click", clickEvent, true);
  window.removeEventListener("auxclick", auxClickEvent, true);
  window.removeEventListener("keydown", keydownEvent, true);
}

function initFilenames(fileNameList, fileByFileName) {
  fileByFilename = fileByFileName;
  filenames = fileNameList;
  nbFilename = filenames.length;
  chapterByIndexes = new Array(nbFilename);
  startIndexByChapters = [];
  showSearcher.reset();

  let filename = filenames[0];

  if (!filename) {
    mode.start();
    return;
  }

  let images = [filename];
  let seppos = filename.lastIndexOf("/");
  let subs = filename.substring(0, seppos);
  let startIndex = 0;
  let chap = {startIndex, images, ichap: 0};
  let seppos2;
  chapterByIndexes[0] = chap;
  startIndexByChapters.push(startIndex);
  for (let i = 1; i < nbFilename; ++i) {
    filename = filenames[i];
    seppos2 = filename.lastIndexOf("/");
    if (seppos2 === seppos && filename.startsWith(subs)) {
      images.push(filename);
    }
    else {
      seppos = seppos2;
      startIndex += images.length;
      images = [filename];
      chap = {startIndex, images, ichap: startIndexByChapters.length};
      subs = filename.substring(0, seppos);
      startIndexByChapters.push(startIndex);
    }

    chapterByIndexes[i] = chap;
  }

  mode.start(currentImageLimit);
}

enableShortcuts();

initFilenames(defaultFileNameList);

for (const d of [
'"$triggered"'
]) {
  if (d.delay)
    setTimeout(d.action, d.delay);
  else
    d.action();
}

'"$force_pixel_distance_code"'
'"$force_mode_code"'
'

if (( $# == 0 && $standalone == 1 )); then
  echo 'showLoader();'
fi

echo '
</script>
</body>
</html>'
