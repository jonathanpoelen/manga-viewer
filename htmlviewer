#!/usr/bin/env bash

set -e

inputs='# default input.conf
space pgdown_or_next
shift+space pgup_or_prev

space restrict webtoon pgdown_or_next 98
space restrict all pgdown_or_next 98
shift+space restrict webtoon pgup_or_prev 98
shift+space restrict all pgup_or_prev 98

z next -5
x next 5
a next -12
s next 12
q next -30
w next 30
e next -100
r next 100

left prev
right next

ctrl+left  next -5
ctrl+right next 5
ctrl+up    next 12
ctrl+down  next -12

< next_chap -1
> next_chap 1

| prev
c pgup_or_prev
v prev
b pgup_or_prev
. prev
/ pgdown_or_next

m rotate -90
, rotate 90

h mode webtoon
j mode double
k mode normal

d info
o info

t toggle_auto_scroll
u add_interval -25
i add_interval 25

# Mouse shortcuts

left_click pgdown_or_next
shift+left_click pgup_or_prev

ctrl+left_click next_chap
shift+ctrl+left_click next_chap -1

@ mouse_assistance

# extra

F1 shortcuts
F10 open
F8 gopen
'

config="${XDG_CONFIG_DIRS:-${XDG_DATA_HOME:-$HOME}/.config}"/htmlviewer
inputconf="$config"/input.conf
triggered=''

usage='Generate a html viewer file

  htmlviewer [-a|-A] [-n] [-s] [-S] [-c <command>] [-e <html>] [-f <filename>]
             [-i <filename>] [-m {normal|double|webtoon|all}] [-t <title>]
             [-x <pixel_distance>] directory...
  htmlviewer -p
  htmlviewer -K
  htmlviewer -h'

help="
  -a
      Allows the creation of html view without file. They can be opened
      directly from the viewer.

  -A
      same as -a, but use gopen command.

  -c <command>
      Add a command. See input.conf syntax.

  -e <html>
      Specify content of html header. By default its contains the html style.

  -f <filename>
      Read directories from <filename>. If - is specified as filename,
      directories are read from the standard input.

        find -type d | fzf | htmlviewer -f- > view.html

  -i <filename>
      Specify configuration file. See input.conf.

  -h
      Show this help.

  -K
      Generates a html file which displays the name of the keys and
      mouse buttons.

  -m {normal|double|webtoon|all}
      Specify default mode.

  -n
      Do not load default configuration files.

      By default load \${XDG_CONFIG_DIRS}/htmlviewer/input.conf with
      \$HOME/.config as default value when XDG_CONFIG_DIRS is unset.

      Currently $inputconf

  -p
      Print default keyboard mapping.

  -s
      Sort input directories (default).

  -S
      Do not sort input directories.

  -t <title>
      Specify title page.

  -x <pixel_distance>
      Specify default value for bottom_pixel command.


  input.conf
      The input.conf file consists of a list of mouse and key bindings,
      for example:

        n next       # go to the next image with the n key
        m rotate 90  # rotates images 90 degrees

      Each line maps a key to an input command.

      In general, keys can be combined with Shift, Ctrl, Alt and Meta:

        shift+Space pgup_or_prev


  input.conf syntax
      <key> <command> [<args>...]

      Newlines always start a new binding. # starts a comment.
      To bind commands to the # key, SHARP can be used.

      <key> is either the literal character the key produces (ASCII,
      Unicode character or Javascript KeyEvent.key). See -K flag.

      <command> is the command itself. It consists of the command name
      and multiple (or none) arguments, all separated by whitespace.

  Special key names
      space
      sharp alias for #
      plus alias for +
      pgup alias for PageUp
      pgdown alias for PageDown
      up alias for ArrowUp
      down alias for ArrowDown
      left alias for ArrowLeft
      right alias for ArrowRight
      left_click for click0
      middle_click for click1
      right_click for click2

      Note: aliases are insensitive case

  Commands
      next [n=1]
          Advance n images. A negative number goes back n images.

      prev [n=1]
          Equivalent to next -n.

      next_chap [n=1]
          Advance n directories. A negative number goes back n directories.

      prev_chap [n=1]
          Equivalent to next -n.

      rotate <deg>
          Rotate an images.

      pgup [percent=100]

      pgdown [percent=100]

      pgdown_or_next [percent=100] [pixel_distance=bottom_pixel]
          Next image when at the bottom of the page, otherwise scroll down.

      pgup_or_prev [percent=100]
          Previous image when at the top of the page, otherwise scroll up.

      mode {normal|double|webtoon|all} [image_limit=0]
          - normal: one image at a time.
          - double: once on 2, the commands pgdown_or_next/pgup_or_prev go to
                    top/bottom of the page rather than go to the next/prev
                    image.
          - webtoon: All images in a chapter are displayed one below the other.
          - all: All images are displayed one below the other.

          image_limit specifies the maximum number of images displayed per
          page. 0 for no limit.

      info
          Show current image position.

      auto_scroll [ms_delay=800]
          Start auto scroll with specific delay.

      toggle_auto_scroll [ms_delay=800]
          Resume or stop auto scroll. Equivalent to auto_scroll when not started.

      add_interval <ms_delay>
          Add delay of auto scroll. Delay can be negative.

      set_bottom_pixel <pixel_distance>
          Number of pixels at the bottom of the page that can be skipped for
          so that pgdown_or_next, auto_scroll and toggle_auto_scroll goes to
          the next image.

          Default is 20.

      add_bottom_pixel <pixel_distance>
          Add pixel_distance. See set_bottom_pixel.

      trigger [ms_delay=0] <command>
          Allows to trigger <command> when opening the page after <ms_delay>.
          The keyboard shortcut is associated with <command>.

          You can put a key that does not exist to make no association:

            nokey trigger 200 auto_scroll 600

            h trigger mode webtoon
            # is equivalent to
            nokey trigger mode webtoon
            h mode webtoon

      mouse {top|bottom|left|right|top_left|top_right|bottom_left|bottom_right} <command>
          Execute <command> only when the mouse pointer is in a certain area.

          Note: Only works with mouse shortcuts.

      mouse_assistance
          Enable or disable the display of mouse area.

      restrict {normal|double|webtoon|all} <command>
          Enable a shortcut for a specific mode.

      shortcuts
          Show shortcuts.

      open
          Open directories.

      gopen
          Open directories. This is a generic version of open which unfortunately
          is less efficient and consumes more memory.

  COPYRIGHT
       By Jonathan Poelen
       License MIT
       https://github.com/jonathanpoelen/manga-viewer
"

declare -A fns=(
  [next]=1
  [prev]=1
  [next_chap]=1
  [prev_chap]=1
  [rotate]=1
  [mode]=1
  [pgup]=1
  [pgdown]=1
  [set_bottom_pixel]=1
  [add_bottom_pixel]=1
  [pgdown_or_next]=1
  [pgup_or_prev]=1
  [info]=1
  [toggle_auto_scroll]=1
  [auto_scroll]=1
  [add_interval]=1
  [trigger]=1
  [mouse]=1
  [mouse_assistance]=1
  [restrict]=1
  [shortcuts]=1
  [open]=1
  [gopen]=1
)

declare -A remap=(
  [space]=' '
  [left]='ArrowLeft'
  [right]='ArrowRight'
  [up]='ArrowUp'
  [down]='ArrowDown'
  [pgup]='PageUp'
  [pgdown]='PageDown'
  [sharp]='#'
  [plus]='+'
  [left_click]='click0'
  [middle_click]='click1'
  [right_click]='click2'
  ['\']='\\'
  [\']=\\\'
)

declare -A mousezone=(
  [xtop]=1
  [xbottom]=2
  [xleft]=4
  [xright]=8
  [xtop_left]=5
  [xleft_top]=5
  [xright_top]=9
  [xtop_right]=9
  [xbottom_left]=6
  [xleft_bottom]=6
  [xbottom_right]=10
  [xright_bottom]=10
  [xall]=15
)

check_n()
{
  if [[ $2 -ne $1 ]]; then
    error="requires $1 argument, $2 but were provided"
    return 1
  fi
}

check_int()
{
  local -i n=$1
  if [[ "$1" != "$n" ]]; then
    error="bad argument: $1 is not a number"
    return 1
  fi
}

check_positive()
{
  local -i n=$1
  if [[ "$1" != "$n" ]] || [[ $n -le 0 ]]; then
    error="bad argument: $1 is not a positive number"
    return 1
  fi
}

init_local_mode()
{
  case "$1" in
    normal)  mode=normalMode;;
    double)  mode=doublePageMode;;
    webtoon) mode=webtoonMode;;
    all)     mode=allMode;;
    *) error="Unknown mode '$1'";
       return 1;;
  esac
}

subcomand()
{
  local fn=$1
  if [[ -z ${fns[$fn]} ]]; then
    error="Unknown command '$fn'"
    return 1
  fi

  shift
  cmd_$fn "$@"
}


cmd_next()
{
  if [[ $# -eq 0 ]]; then
    code='mode.advance(1);'
  else
    check_n 1 $#
    check_int "$1"
    code="mode.advance($1);"
  fi
}

cmd_prev()
{
  if [[ $# -eq 0 ]]; then
    code='mode.advance(-1);'
  else
    check_n 1 $#
    check_int "$1"
    local -i n=$1
    ((n=-n))
    code="mode.advance($n);"
  fi
}

cmd_next_chap()
{
  if [[ $# -eq 0 ]]; then
    code='mode.advanceChap(1);'
  else
    check_n 1 $#
    check_int "$1"
    code="mode.advanceChap($1);"
  fi
}

cmd_prev_chap()
{
  if [[ $# -eq 0 ]]; then
    code='mode.advanceChap(-1);'
  else
    check_n 1 $#
    check_int "$1"
    local -i n=$1
    ((n=-n))
    code="mode.advanceChap($n);"
  fi
}

cmd_rotate()
{
  check_n 1 $#
  check_int "$1"
  code="rotate($1);"
}

cmd_mode()
{
  local mode image_limit=0
  init_local_mode "$1"

  if [[ $# -gt 1 ]]; then
    check_n 2 $#
    check_int "$2"
    image_limit="$2"
  fi

  code="selectMode($mode, $image_limit);"
}

cmd_pgup_or_prev()
{
  if [[ $# -eq 0 ]]; then
    code='upOrPrev(body.clientHeight);'
  else
    check_n 1 $#
    check_int "$1"
    code="upOrPrev(body.clientHeight * ($1 / 100));"
  fi
}

cmd_pgdown_or_next()
{
  if [[ $# -eq 0 ]]; then
    code='downOrNext(bottomPixelDistance, body.clientHeight);'
  elif [[ $# -eq 1 ]]; then
    check_int "$1"
    code="downOrNext(bottomPixelDistance, body.clientHeight * ($1 / 100));"
  else
    check_n 2 $#
    check_int "$1"
    check_positive "$2"
    code="downOrNext($2, body.clientHeight * ($1 / 100));"
  fi
}

cmd_pgup()
{
  if [[ $# -eq 0 ]]; then
    code='body.scrollTop -= body.clientHeight;'
  else
    check_n 1 $#
    check_int "$1"
    code="body.scrollTop -= body.clientHeight * ($1 / 100);"
  fi
}

cmd_pgdown()
{
  if [[ $# -eq 0 ]]; then
    code='body.scrollTop += body.clientHeight;'
  else
    check_n 1 $#
    check_int "$1"
    code="body.scrollTop += body.clientHeight * ($1 / 100);"
  fi
}

cmd_info()
{
  check_n 0 $#
  code='showImageInfo();'
}

cmd_auto_scroll()
{
  if [[ $# -eq 0 ]]; then
    code='startAutoScroll(800);' ;
  else
    check_n 1 $#
    check_positive "$1"
    code="startAutoScroll($1);"
  fi
}

cmd_toggle_auto_scroll()
{
  if [[ $# -eq 0 ]]; then
    code='toggleAutoScroll(800);' ;
  else
    check_n 1 $#
    check_positive "$1"
    code="toggleAutoScroll($1);"
  fi
}

cmd_add_interval()
{
  check_n 1 $#
  check_int "$1"
  code="addAutoScrollInterval($1);"
}

cmd_set_bottom_pixel()
{
  check_n 1 $# &&
  check_positive "$1" &&
  code="bottomPixelDistance = $1;"
}

cmd_add_bottom_pixel()
{
  check_n 1 $#
  check_int "$1"
  code="bottomPixelDistance = max(0, bottomPixelDistance + $1);"
}

cmd_trigger()
{
  local -i delay=$1
  [[ "$1" != "$delay" ]] && delay=0 || shift

  subcomand "$@"
  triggered+="{action: function(){$code}, delay: $delay},"$'\n'
}

cmd_mouse()
{
  local zone=${mousezone["x$1"]}
  if [[ -z $zone ]]; then
    error="Unknown zone '$1'"
    return 1
  fi

  shift
  subcomand "$@"
  code="if (isInZone(arguments[0], $zone)) { $code }"
}

cmd_mouse_assistance()
{
  check_n 0 $#
  code='toggleMouseAssistance()'
}

cmd_restrict()
{
  init_local_mode "$1"
  shift
  subcomand "$@"
}

cmd_shortcuts()
{
  check_n 0 $#
  code='showShorcuts();'
}

cmd_open()
{
  check_n 0 $#
  code='showLoader(true);'
}

cmd_gopen()
{
  check_n 0 $#
  code='showLoader(false);'
}


minihelp()
{
  echo "$usage"
  echo
  echo "input.conf path: $inputconf"
  if [[ ! -f "$inputconf" ]]; then
    echo '  But not found, a default configuration will be used (see -p).'
  fi
  echo
  echo 'Use -a for create a view without directory. Directories to be loaded'
  echo 'will be asked when opening the html file.'
  echo
  echo 'Use -h for more information.'
}

typeset -i standalone=0
inputdirs=''
hasinput=0
sort=1
htmlheader=
force_mode_code=
force_pixel_distance_code=
title="${@:0:200}"
declare -a cmds=()

while getopts 'aAsSnpKi:c:e:t:f:x:m:h?' opt ; do
  case $opt in
    s) sort=1;;
    S) sort=0;;
    n) inputconf=''
       hasinput=0;;
    i) inputconf="$OPTARG"
       hasinput=1;;
    e) htmlheader="$OPTARG";;
    c) cmds+=($OPTIND "$OPTARG");;
    t) title="$OPTARG";;
    f) inputdirs="$OPTARG";;
    m) cmd_mode $OPTARG && force_mode_code=$code || {
         echo "arg $OPTIND: -m $OPTARG: $error" >&2
         exit 2
       };;
    x) cmd_set_bottom_pixel "$OPTARG" && force_pixel_distance_code="$OPTARG" || {
         echo "arg $OPTIND: -x $OPTARG: $error" >&2
         exit 2
       };;
    p) echo -n "$inputs";
       exit;;
    K) echo '<!DOCTYPE html>
<html><head><title>Key viewer</title><meta charset="Utf-8"/></head>
<p>Press keys on the keyboard to see what the KeyboardEvent'\''s key values is for each one.</p>
<div id="output"></div>
<script>const output = document.getElementById("output");
window.addEventListener("keydown", function(event) {
  const p = document.createElement("p");
  p.textContent = `key="${event.key}"`;
  output.appendChild(p);
}, true);
function mouseEvent(event) {
  const p = document.createElement("p");
  p.textContent = `key="click${event.button}"`;
  output.appendChild(p);
};
window.addEventListener("click", mouseEvent, true);
window.addEventListener("auxclick", mouseEvent, true);
</script></body></html>';
       exit;;
    a) standalone=1 ;;
    A) standalone=2 ;;
    h) echo "$usage";
       echo "$help"
       exit;;
    ?) minihelp;
       exit 2;;
  esac
done
shift $(($OPTIND - 1))

if [[ $# -eq 0 ]] && (( $standalone == 0 )); then
  minihelp >&2
  exit 1
fi

shortcuts=()
raw_shortcuts=()
declare -A shortcuts_by_mode=()

parse_input_line()
{
  local key=$1
  [[ ${key[0]} != '#' ]] || return

  local fn=$2
  [[ ${fn[0]} != '#' ]] || {
    error="key without command"
    return 1
  }

  if [[ -z ${fns[$fn]} ]]; then
    error="Unknown command '$fn'"
    return 1
  fi

  shift 2

  # strip comment
  local -a args=()
  for arg in "$@"; do
    [[ ${arg[0]} != '#' ]] || break
    args+=("$arg")
  done

  local mode # set by restrict
  cmd_$fn "${args[@]}" || error="$fn: $error"

  # extract controls and convert key to lowercase
  local -A control=([alt]=0 [ctrl]=0 [shift]=0 [meta]=0)
  local ifs="$IFS"
  IFS=+
  local -a keys=($key)
  IFS="$ifs"

  if [[ $key != nokey ]]; then
    local htmlized="${keys[@]^}"
    htmlized="${htmlized//_click/Click}"
    htmlized="${htmlized//&/&amp;}"
    htmlized="${htmlized//</&lt;}"
    htmlized="${htmlized// /+}"
    htmlized="${htmlized/sharp/#}"
    htmlized="${htmlized/plus/#}"
    local cmdraw
    # remove trigger prefix
    if [[ $fn = trigger ]]; then
      # remove delay prefix
      if [[ ${args[@]} =~ [0-9] ]]; then
        local tmp=("${args[@]}")
        tmp[0]=''
        cmdraw="${tmp[@]}"
      else
        cmdraw="${args[@]}"
      fi
    else
      cmdraw="$fn ${args[@]}"
    fi
    raw_shortcuts+=("<tr><td>$htmlized</td><td>$cmdraw</td></tr>")
  fi

  for key in "${keys[@]}"; do
    key=${key,,}
    control["$key"]=1
  done

  local newkey="${remap[$key]}"
  [[ -z $newkey ]] || key="$newkey"
  local shortcut="{alt: ${control[alt]}, ctrl: ${control[ctrl]}, shift: ${control[shift]}, meta: ${control[meta]}, key: '$key', action: function(){ $code }},"$'\n'

  if [[ -z $mode ]]; then
    shortcuts+=("$shortcut")
  else
    shortcuts_by_mode[$mode]+="$shortcut"
  fi
}

# read input.conf
if [[ -f "$inputconf" ]]; then
  inputs="$(<$inputconf)"
elif [[ $hasinput -eq 1 ]]; then
  echo "Unknown '$inputconf'" >&2
  exit 1
fi

errors=''

# parse input.conf
nline=0
while read -r line ; do
  ((++nline))
  [[ -n $line ]] || continue
  error=
  parse_input_line $line ||:
  [[ -z $error ]] || errors+="line $nline: $error in '$line'"$'\n'
done <<<"$inputs"

# parse -c options
for ((i=0; i < ${#cmds[@]}; i+=2)); do
  error=
  cmd="${cmds[$((i+1))]}"
  parse_input_line $cmd ||:
  [[ -z $error ]] || errors+="arg ${cmds[$i]}: $error in '$cmd'"$'\n'
done

if [[ -n $errors ]]; then
  echo -n "$errors" >&2
  exit 2
fi

# read input directories
declare -a dirs=()
if [[ -n $inputdirs ]]; then
  [[ $inputdirs != '-' ]] || inputdirs=/dev/stdin
  while read -r path; do
    dirs+=("$path")
  done <"$inputdirs"
fi


echo '<!DOCTYPE html>
<!-- https://github.com/jonathanpoelen/manga-viewer -->
<html>
<head>
  <title>Viewer: '"$title"'</title>
  <meta charset="Utf-8"/>
  <meta http-equiv="cache-control" content="max-age=0"/>
  <meta http-equiv="cache-control" content="no-cache"/>
  <meta http-equiv="expires" content="0"/>
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <style>
div, body {
  margin:0;
  padding:0;
  background:#000;
}

img {
  display:block;
  margin:auto;
  max-width:100%;
}

#info, #mouseAssistance {
  display:none;
  z-index:10;
  position:absolute;
  top:0px;
}

#info {
  padding:.5em;
  color:#000;
  background:#eee;
  border:1px #000 solid;
}

#mouseAssistance {
  width:100%;
  height:100%;
  grid-template-columns:auto auto;
  background:transparent;
}
#mouseAssistance > span {
  margin:0;
  padding:0;
  display:block;
  background:transparent;
  border:1px yellow solid;
  border-left:0;
  border-bottom:0;
}
#mouseAssistance > span:hover {
  background: rgba(0,0,0,.2);
}
#mouseAssistance > span:nth-child(1), #mouseAssistance > span:nth-child(2) {
  border-top:0;
}

#shortcuts, #loader {
  display:none;
  width: 100%;
}

#loaderForm {
  display: table;
  background:#eee;
  margin: auto;
  padding: 2em;
  text-align:center;
}

#loaderForm > p {
  color: #777;
}

#loaderForm > label, #loaderForm > input {
  display: block;
  margin: 1em;
}

#loaderForm > input {
  display: inline-block;
}

#shortcuts > table {
  background:#eee;
  margin: auto;
  padding: 2em;
  // border-collapse: collapse;
  border-spacing: 0;
}

#shortcuts > table tr:nth-child(even) {
  background:#ddd;
}

#shortcuts > table td {
  padding: .5em;
}

#shortcuts > table td:first-child {
  text-align:right;
}

#shortcuts table tr {
  border-bottom: 1px solid black;
}
  </style>
  '"$htmlheader"'
</head>
<body>
<img src="" class="imgWrapper"/>
<div id="info"></div>
<div id="loader">
  <form id="loaderForm">
    <label><input id="useGOpen" type="checkbox">Use the generic method (takes more memory and is slower).</label>
    <p>Due to browser security limitations, a web page cannot know the full path of files.<br/>For this reason, it may be necessary to specify it in the prefix field so that files are found.</p>
    <label>Prefix: <input id="prefix" type="text"/></label>
    <label>Directories: <input id="dirs" type="file" webkitdirectory="" multiple=""/></label>
    <p id="finalpath"></p>
    <input type="submit"/>
    <input id="closeLoader" type="button" value="Cancel"/>
  </form>
</div>
<div id="shortcuts"><table>'"${raw_shortcuts[@]}"'</table></div>
<div id="mouseAssistance"><span></span><span></span><span></span><span></span></div>
<script type="text/javascript">
"use strict";

const defaultFileNameList = ['

if [[ $# -ne 0 ]]; then
  {
    if [[ $sort -eq 1 ]]; then
      find "$@" "${dirs[@]}" -type f | sort -V
    else
      for d in "$@" "${dirs[@]}"; do
        find "$d" -type f | sort -V
      done
    fi
  } | sed '/\(Thumbs\.db\|\.directory|\.html\)$/d;s/"/\\"/g;s/^/"/;s/$/",/g'
fi

echo '];

let ifile = +window.location.search.split("=")[1] || 0;
const img = document.getElementsByTagName("img")[0];
const info = document.getElementById("info");
const body = document.documentElement;

const min = Math.min;
const max = Math.max;

let fileByFilename;
let filenames;
let nbFilename;
// chapterByIndexes: [{startIndex: from filenames, images: [filename...], ichap: Number}...]
// chapterByIndexes.length == nbFilename
let chapterByIndexes;
let startIndexByChapters;

const rotate = function(deg) {
  const r = img.getAttribute("style");
  if (r) {
    deg += Number(r.substring(25, r.length-4));
  }
  img.setAttribute("style", `transform:rotate(${deg}deg)`);
};

const toBottomOnLoad = function(image) {
  image.onload = function(e) {
    body.scrollTop = image.clientHeight;
    image.onload = undefined;
  };
};

const scrollOnImageAfterDelay = function(image, delay, addTop) {
  let trigger = false;

  const timerId = setTimeout(function() {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      image.onload = undefined;
    }
    else {
      trigger = true;
    }
  }, delay);

  image.onload = function(e) {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      clearInterval(timerId);
    }
    else {
      trigger = true;
    }
    image.onload = undefined;
  };
};

const setImage = function(img, filename) {
  if (fileByFilename) {
    const reader = new FileReader();
    reader.onload = (e) => {
      img.src = e.target.result;
    };
    reader.readAsDataURL(fileByFilename[filename]);
  }
  else {
    img.src = filename;
  }
};

const normalMode = {
  start: function() {
    setImage(img, filenames[ifile]);
  },
  stop: function() {},
  next: function() {
    if (ifile !== nbFilename) {
      setImage(img, filenames[++ifile]);
      body.scrollTop = 0;
    }
  },
  prev: function() {
    if (ifile) {
      setImage(img, filenames[--ifile]);
      toBottomOnLoad(img);
    }
  },
  advance: function(x) {
    ifile = max(0, min(ifile+x, nbFilename-1));
    setImage(img, filenames[ifile]);
    body.scrollTop = 0;
  },
  advanceChap: function(x) {
    const chap = chapterByIndexes[ifile];
    const ichap = max(0, min(chap.ichap + x, startIndexByChapters.length-1));
    ifile = startIndexByChapters[ichap];
    // when last chapter, go to end image
    if (x > 0 && ichap === chap.ichap) {
      ifile += chap.images.length - 1;
    }
    setImage(img, filenames[ifile]);
    body.scrollTop = 0;
  },
  syncIFile: function() {},
};

const doublePageMode = {
  start: function() {
    this.db = false;
  },
  stop: function() {},
  next: function() {
    if (this.dp) {
      if (ifile === nbFilename) {
        return;
      }
      setImage(img, filenames[++ifile]);
    }
    this.dp = !this.dp;
    body.scrollTop = 0;
  },
  prev: function() {
    if (this.dp) {
      if (!ifile) {
        return;
      }
      setImage(img, filenames[--ifile]);
      toBottomOnLoad(img);
    }
    else {
      body.scrollTop = img.clientHeight;
    }
    this.dp = !this.dp;
  },
  advance: function(x) {
    this.db = false;
    normalMode.advance(x);
  },
  advanceChap: function(x) {
    this.db = false;
    normalMode.advanceChap(x);
  },
  syncIFile: function() {},
};

const appendImages = function(elem, urls, startIndex) {
  const nUrl = urls.length;
  for (let i = 0; i < nUrl; ++i, ++startIndex) {
    const img = document.createElement("img");
    setImage(img, urls[i]);
    img.dataset.i = startIndex;
    elem.appendChild(img);
  }
};

const removeChildren = function(elem) {
  while (elem.lastChild) {
    elem.removeChild(elem.lastChild);
  }
}

const groupPageModeBase = {
  eimgs: (function(){
    const div = document.createElement("div");
    div.className = "imgWrapper";
    return div;
  })(),
  syncIFile: function() {
    const img = document.elementFromPoint(body.clientWidth / 2, 10);
    const i = img.dataset.i;
    if (i) {
      ifile = +i;
    }
  },
  _start: function(chapterByIndexes, startIndexByChapters, imageLimit) {
    if (!imageLimit) {
      this.chapterByIndexes = chapterByIndexes;
    }
    else if (imageLimit in this.chapterByIndexesByImageLimits) {
      this.chapterByIndexes = this.chapterByIndexesByImageLimits[imageLimit];
    }
    else {
      const chaps = new Array(filenames.length);
      let startIndex = 0;
      for (const chapIndex of startIndexByChapters) {
        const images = chapterByIndexes[chapIndex].images;
        const imageLen = images.length;
        if (imageLen > imageLimit) {
          for (let i = 0; i < imageLen; i += imageLimit) {
            const subImages = images.slice(i, i + imageLimit);
            const subImageLen = subImages.length;
            chaps.fill({startIndex, images: subImages}, startIndex, startIndex + subImageLen);
            startIndex += subImageLen;
          }
        }
        else {
          chaps.fill({startIndex, images}, startIndex, startIndex + imageLen);
          startIndex += imageLen;
        }
      }
      this.chapterByIndexesByImageLimits[imageLimit] = chaps;
      this.chapterByIndexes = chaps;
    }

    document.body.removeChild(img);
    document.body.appendChild(this.eimgs);
    this.updateChapter();
    const i = this.currentChapter.startIndex;
    const image = this.eimgs.childNodes[ifile-i];
    // TODO calculate the scroll in relation to the position of the image
    scrollOnImageAfterDelay(image, 100, 0);
  },
  updateChapter: function(){
    const chap = this.chapterByIndexes[ifile];
    this.currentChapter = chap;
    removeChildren(this.eimgs);
    appendImages(this.eimgs, chap.images, chap.startIndex);
  },
  stop: function() {
    this.syncIFile();
    setImage(img, filenames[ifile]);
    document.body.removeChild(this.eimgs);
    document.body.appendChild(img);
    // TODO calculate the scroll in relation to the position of the image
    body.scrollTop = 0;
  },
  next: function() {
    const i = this.currentChapter.startIndex + this.currentChapter.images.length;
    if (i !== nbFilename) {
      ifile = i;
      this.updateChapter();
      body.scrollTop = 0;
    }
  },
  prev: function() {
    if (this.currentChapter.startIndex) {
      ifile = this.currentChapter.startIndex - 1;
      this.updateChapter();
      const image = this.eimgs.lastChild;
      scrollOnImageAfterDelay(image, 100, 100);
    }
  },
  advance: function(x) {
    this.syncIFile();
    ifile = max(0, min(ifile+x, nbFilename-1));
    const chap = this.chapterByIndexes[ifile];
    if (this.currentChapter === chap) {
      body.scrollTop = this.eimgs.children[ifile - chap.startIndex].offsetTop;
    }
    else {
      body.scrollTop = 0;
      this.currentChapter = chap;
      removeChildren(this.eimgs);
      appendImages(this.eimgs, chap.images, chap.startIndex);
      const image = this.eimgs.childNodes[ifile-chap.startIndex];
      scrollOnImageAfterDelay(image, 100, 0);
    }
  },
  advanceChap: function(x) {
    this.syncIFile();
    let chap = chapterByIndexes[this.chapterByIndexes[ifile].startIndex];
    const prevIChap = chap.ichap;
    const ichap = max(0, min(prevIChap + x, startIndexByChapters.length-1));
    ifile = startIndexByChapters[ichap];
    // when last chapter, go to end image
    if (x > 0 && ichap === prevIChap) {
      ifile += chap.images.length - 1;
    }
    chap = this.chapterByIndexes[ifile];
    body.scrollTop = 0;
    this.currentChapter = chap;
    removeChildren(this.eimgs);
    appendImages(this.eimgs, chap.images, chap.startIndex);
    const image = this.eimgs.childNodes[ifile-chap.startIndex];
    scrollOnImageAfterDelay(image, 100, 0);
  },
};

const webtoonMode = Object.assign({
  chapterByIndexesByImageLimits: {},
  start: function(imageLimit) {
    this._start(chapterByIndexes, startIndexByChapters, imageLimit);
  },
}, groupPageModeBase);

const allMode = Object.assign({
  chapterByIndexesByImageLimits: {},
  start: function(imageLimit) {
    this._start([{startIndex: 0, images: filenames}], [0], imageLimit);
  },
}, groupPageModeBase);

let mode = normalMode;
let currentImageLimit = -1;
let bottomPixelDistance = 20;

const downOrNext = function(d, height) {
  if (body.scrollTop + body.clientHeight >= body.scrollHeight - d) {
    mode.next();
  }
  else {
    body.scrollTop += height || body.clientHeight;
  }
};

const upOrPrev = function(height) {
  if (body.scrollTop == 0) {
    mode.prev();
  }
  else {
    body.scrollTop -= height || body.clientHeight;
  }
};

//@{
let autoScrollDelay = null;
let autoScrollTimerId = null;

const startAutoScroll = function(delay) {
  console.log(`delay: ${delay}`);
  clearInterval(autoScrollTimerId);
  autoScrollDelay = delay;
  autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
};

const toggleAutoScroll = function(delay) {
  if (autoScrollDelay === null) {
    startAutoScroll(delay);
  }
  else if (autoScrollTimerId === null) {
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  else {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = null;
  }
};

const addAutoScrollInterval = function(delay) {
  autoScrollDelay = max(1, (autoScrollDelay || 800) + delay);
  if (autoScrollTimerId !== null) {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  console.log(`autoScrollDelay: ${autoScrollDelay} (+${delay})`);
};
//@}

const osd = (function() {
  let resumeAutoScroll = false;
  let close;
  const removeOSD = function(ev) {
    if (!close(ev)) {
      window.removeEventListener("keydown", removeOSD, true);
      if (resumeAutoScroll) {
        resumeAutoScroll = false;
        if (autoScrollTimerId === null) {
          autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
        }
      }
    }
  };
  const open = function(closeCallback) {
    if (autoScrollTimerId !== null) {
      clearInterval(autoScrollTimerId);
      autoScrollTimerId = null;
      resumeAutoScroll = true;
    }

    close = closeCallback;
    window.addEventListener("keydown", removeOSD, true);
  }
  open.close = removeOSD;
  return open;
})();

const showImageInfo = function() {
  let scrollInfo = "";
  if (autoScrollTimerId !== null) {
    scrollInfo = `[auto-scroll: ${autoScrollDelay}ms]`;
  }
  mode.syncIFile();
  const chap = chapterByIndexes[ifile];
  info.textContent = `[${ifile+1}/${nbFilename}][Chapter: \
${chap.ichap+1}/${startIndexByChapters.length}][Img: ${ifile-chap.startIndex+1}/${chap.images.length}]${scrollInfo} \
${filenames[ifile]}`;
  info.style.display = "block";
  info.style.top = `${body.scrollTop}px`;
  osd(() => { info.style.display = "none"; });
};

const modal = function(closeCallback) {
  const img = document.getElementsByClassName("imgWrapper")[0];
  const display = img.style.display;
  const scrollTop = body.scrollTop;
  body.scrollTop = 0;
  img.style.display = "none";
  disableShortcuts();
  osd(function(e){
    if (!closeCallback(e)) {
      img.style.display = display;
      body.scrollTop = scrollTop;
      enableShortcuts();
      return false;
    }
    return true;
  });
};
modal.close = osd.close;

const showShorcuts = (function() {
  const shortcutsDesc = document.getElementById("shortcuts");
  return function() {
    modal((e) => {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "PageDown":
        case "PageUp":
        case "Home":
        case "End":
        case "Ctrl":
        case "OS":
        case "Control":
        case "Shift":
        case "Alt":
        case "AltGraph":
        case " ":
        // browser search shortcut
        case "/":
        case "f"/* + ctrl */:
        case "F3":
        // dev
        case "F12":
          return true;
      }
      shortcutsDesc.style.display = "none";
    });
    shortcutsDesc.style.display = "block";
  }
})();

const showLoader = (function() {
  const loader = document.getElementById("loader");
  const closeLoader = document.getElementById("closeLoader");
  const loaderForm = document.getElementById("loaderForm");
  const prefixElement = document.getElementById("prefix");
  const dirsElement = document.getElementById("dirs");
  const pathElement = document.getElementById("finalpath");
  const useGOpenElement = document.getElementById("useGOpen");
  const files = dirs.files;
  const closeEvent = {key: "Escape"};
  const regSplit = /([0-9]+(?:\.[0-9]+)?|[^0-9]+)/g;
  const regDigit = /^[0-9]/;

  let isFilenameMode = true;

  const getPrefix = function() {
    let prefix = prefixElement.value;
    if (prefix && !prefix.endsWith("/")) {
      prefix += "/";
    }
    return prefix;
  };

  const updateFinalPath = function() {
    const file = files[0];
    if (file) {
      const path = document.createElement("b");
      path.textContent = getPrefix() + file.webkitRelativePath;
      pathElement.textContent = "Final path of one of the files: ";
      pathElement.appendChild(path);
    }
  };

  prefixElement.addEventListener("keyup", updateFinalPath, true);
  dirsElement.addEventListener("change", updateFinalPath, true);

  useGOpenElement.addEventListener("click", function(e) {
    showLoader(!useGOpenElement.checked);
  })

  loaderForm.addEventListener("submit", function(e) {
    e.preventDefault();
    e.stopPropagation();

    const filenameDatas = [];
    for (let i = 0; i < files.length; ++i) {
      const parts = [];
      const file = files[i];
      const path = file.webkitRelativePath;
      // split by string and number
      for (const m of path.matchAll(regSplit)) {
        // m[0]
        parts.push(regDigit.test(m[0]) ? Number(m[0]) : m[0]);
      }
      filenameDatas.push([path, parts, file]);
    }

    // natural sort
    filenameDatas.sort(function(a, b) {
      a = a[1];
      b = b[1];
      const alen = a.length;
      const blen = b.length;
      if (alen < blen) return -1;
      if (alen > blen) return 1;
      for (let i = 0; i < alen; ++i) {
        const x = a[i];
        const y = b[i];
        if (x < y) return -1;
        if (x > y) return 1;
      }
      return 0;
    });

    if (isFilenameMode) {
      const prefix = getPrefix();
      if (localStorage) {
        localStorage.setItem("prefix", prefix);
      }

      const filenameLength = filenameDatas.length;
      for (let i = 0; i < filenameLength; ++i) {
        filenameDatas[i] = prefix + filenameDatas[i][0];
      }

      initFilenames(filenameDatas);
    }
    else {
      const prefix = getPrefix();
      if (localStorage) {
        localStorage.setItem("prefix", prefix);
      }

      const filenameLength = filenameDatas.length;
      const filenames = new Array(filenameLength);
      const fileByFilename = {};
      for (let i = 0; i < filenameLength; ++i) {
        filenames[i] = filenameDatas[i][0];
        fileByFilename[filenames[i]] = filenameDatas[i][2];
      }

      initFilenames(filenames, fileByFilename);
    }

    modal.close(closeEvent);
    body.scrollTop = 0;
  }, true);

  closeLoader.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    modal.close(closeEvent);
  }, true);

  return function(mode) {
    isFilenameMode = mode;
    modal((e) => {
      if (e.key == "Escape") {
        loader.style.display = "none";
        prefixElement.blur();
        return false;
      }
      return true;
    });
    const notice = loader.firstElementChild.firstElementChild;
    notice.nextElementSibling.style.display = isFilenameMode ? "block" : "none";
    notice.nextElementSibling.nextElementSibling.style.display = isFilenameMode ? "inline" : "none";
    pathElement.style.display = isFilenameMode ? "block" : "none";
    useGOpenElement.checked = !isFilenameMode;
    loader.style.display = "block";
    if (isFilenameMode) {
      prefixElement.value = (localStorage && localStorage.getItem("prefix")) || "";
      updateFinalPath();
      prefixElement.focus();
    }
  }
})();

const toggleMouseAssistance = (function() {
  const style = document.getElementById("mouseAssistance").style;
  let timerId = null;
  let enabled = false;

  const hideAssistance = function() {
    clearInterval(timerId);
    timerId = null;
    style.display = "none";
  };

  const showAssistance = function(e) {
    style.top = `${body.scrollTop}px`;
    style.display = "grid";
    clearInterval(timerId);
    timerId = setTimeout(hideAssistance, 200);
  };

  return function() {
    if (enabled) {
      enabled = false;
      window.removeEventListener("mousemove", showAssistance, true);
    }
    else {
      enabled = true;
      window.addEventListener("mousemove", showAssistance, true);
    }
  };
})();

const isInZone = function(e, zone) {
  const isTop = (e.clientY < window.innerHeight / 2);
  const isLeft = (e.clientX < window.innerWidth / 2);
  // top=1 bottom=2 left=4 right=8
  switch (zone) {
    case 1: return isTop;
    case 2: return !isTop;
    case 4: return isLeft;
    case 8: return !isLeft;
    case 5: return isTop && isLeft;
    case 9: return isTop && !isLeft;
    case 6: return !isTop && isLeft;
    case 10: return !isTop && !isLeft;
  }
};

const selectMode = function(newMode, imageLimit) {
  if (mode !== newMode || currentImageLimit !== imageLimit) {
    currentImageLimit = imageLimit;
    mode.stop();
    mode = newMode;
    mode.start(imageLimit);
    updateShortcuts(mode);
  }
};

const rgxClickName = /^click\d+$/
const createActions = function(shortcuts, actionsByKeys, actionsByClicks){
  actionsByKeys = actionsByKeys || {};
  actionsByClicks = actionsByClicks || [];

  for (const d of shortcuts) {
    let actionsByControls = actionsByKeys[d.key];
    if (!actionsByControls) {
      actionsByControls = {};
      actionsByKeys[d.key] = actionsByControls;
      if (rgxClickName.test(d.key)) {
        actionsByClicks[d.key.substr(5)] = actionsByControls
      }
    }
    actionsByControls[d.alt + (d.ctrl << 1) + (d.shift << 2) + (d.meta << 3)] = d.action;
  }

  return [actionsByKeys, actionsByClicks];
};

// contains key and mouse actions
const [globalActionsByKeys, globalActionsByClicks] = createActions(['"${shortcuts[@]}"']);

const createModActions = function(shortcuts) {
  const actionsByKeys = {};
  for (const d in globalActionsByKeys) {
    actionsByKeys[d] = Object.assign({}, globalActionsByKeys[d]);
  }
  return createActions(shortcuts, actionsByKeys, Array.from(globalActionsByClicks));
};
'
for mode in "${!shortcuts_by_mode[@]}"; do
  echo "${mode}.shortcuts = createModActions([${shortcuts_by_mode[$mode]}]);"
done
echo '

let actionsByKeys = globalActionsByKeys;
let actionsByClicks = globalActionsByClicks;
let actionsForPrimaryClick = actionsByClicks[0];

const keydownEvent = function(e) {
  const actions = actionsByKeys[e.key] || actionsByKeys[e.key.toLowerCase()];
  if (actions) {
    const action = actions[e.altKey + (e.ctrlKey << 1) + (e.shiftKey << 2) + (e.metaKey << 3)]
                  // assume that Shift+Key = Key (ex. Shift+< = <)
                || actions[e.altKey + (e.ctrlKey << 1) + (e.metaKey << 3)];
    if (action) {
      e.preventDefault();
      e.stopPropagation();
      action();
      return false;
    }
  }
  return true;
};

const clickEvent = function(e) {
  const action = actionsForPrimaryClick[e.altKey + (e.ctrlKey << 1) + (e.shiftKey << 2) + (e.metaKey << 3)];
  if (action) {
    e.preventDefault();
    e.stopPropagation();
    action();
    return false;
  }
  return true;
};

const auxClickEvent = function(e) {
  let actions = actionsByClicks[e.button];
  if (actions) {
    const action = actions[e.altKey + (e.ctrlKey << 1) + (e.shiftKey << 2) + (e.metaKey << 3)];
    if (action) {
      e.preventDefault();
      e.stopPropagation();
      action(e);
      return false;
    }
    return true;
  }
};

function updateShortcuts(mode) {
  window.removeEventListener("click", clickEvent, true);
  window.removeEventListener("auxclick", auxClickEvent, true);

  actionsByKeys = mode.shortcuts ? mode.shortcuts[0] : globalActionsByKeys;
  actionsByClicks = mode.shortcuts ? mode.shortcuts[1] : globalActionsByClicks;

  if (0 in actionsByClicks) {
    actionsForPrimaryClick = actionsByClicks[0];
    window.addEventListener("click", clickEvent, true);
  }

  if (actionsByClicks.length > 1) {
    window.addEventListener("auxclick", auxClickEvent, true);
  }
}

function enableShortcuts() {
  window.addEventListener("keydown", keydownEvent, true);
  updateShortcuts(mode);
}

function disableShortcuts() {
  window.removeEventListener("click", clickEvent, true);
  window.removeEventListener("auxclick", auxClickEvent, true);
  window.removeEventListener("keydown", keydownEvent, true);
}

function initFilenames(fileNameList, fileByFileName) {
  fileByFilename = fileByFileName;
  filenames = fileNameList;
  nbFilename = filenames.length;
  chapterByIndexes = new Array(nbFilename);
  startIndexByChapters = [];

  let filename = filenames[0];

  if (!filename) {
    mode.start();
    return;
  }

  let images = [filename];
  let seppos = filename.lastIndexOf("/");
  let subs = filename.substring(0, seppos);
  let startIndex = 0;
  let chap = {startIndex, images, ichap: 0};
  let seppos2;
  chapterByIndexes[0] = chap;
  startIndexByChapters.push(startIndex);
  for (let i = 1; i < nbFilename; ++i) {
    filename = filenames[i];
    seppos2 = filename.lastIndexOf("/");
    if (seppos2 == seppos && filename.startsWith(subs)) {
      images.push(filename);
    }
    else {
      seppos = seppos2;
      startIndex += images.length;
      images = [filename];
      chap = {startIndex, images, ichap: startIndexByChapters.length};
      subs = filename.substring(0, seppos);
      startIndexByChapters.push(startIndex);
    }

    chapterByIndexes[i] = chap;
  }

  mode.start();
}

enableShortcuts();

initFilenames(defaultFileNameList);

for (const d of [
'"$triggered"'
]) {
  if (d.delay)
    setTimeout(d.action, d.delay);
  else
    d.action();
}

'"$force_pixel_distance_code"'
'"$force_mode_code"'
'

if [[ $# -eq 0 ]]; then
  if (( $standalone == 1 )); then
    echo 'showLoader(true);'
  else
    echo 'showLoader(false);'
  fi
fi

echo '
</script>
</body>
</html>'
