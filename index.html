<!DOCTYPE html>
<!-- https://github.com/jonathanpoelen/manga-viewer -->
<html>
<head>
  <meta charset="Utf-8"/>
  <title>Directories: </title>
  <meta http-equiv="cache-control" content="max-age=0"/>
  <meta http-equiv="cache-control" content="no-cache"/>
  <meta http-equiv="expires" content="0"/>
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <style>
div, body {
  margin:0;
  padding:0;
  background:#000;
}

img {
  display:block;
  margin:auto;
  max-width:100%;
}

#info, #goto, #mouseAssistance {
  display:none;
  z-index:10;
  position:absolute;
  top:0px;
}

#info, #goto {
  padding:.5em;
  color:#000;
  background:#eee;
  border:1px #000 solid;
}

#mouseAssistance {
  width:100%;
  height:100%;
  grid-template-columns:auto auto;
  background:transparent;
}
#mouseAssistance > span {
  margin:0;
  padding:0;
  display:block;
  background:transparent;
  border:1px yellow solid;
  border-left:0;
  border-bottom:0;
}
#mouseAssistance > span:hover {
  background: rgba(0,0,0,.2);
}
#mouseAssistance > span:nth-child(1), #mouseAssistance > span:nth-child(2) {
  border-top:0;
}

#shortcuts, #loader, #searcher {
  display:none;
  width: 100%;
}

#repositoryUrl {
  background:#050505;
  margin: auto;
  padding: .5em;
  text-align: center;
  line-height: 2.5em;
}

#repositoryUrl, #repositoryUrl > a {
  color: #888;
}
#repositoryUrl > a:hover {
  color: #aaa;
}

#loaderForm {
  display: table;
  background:#eee;
  margin: auto;
  padding: 2em;
  text-align:center;
}

#loaderForm > p {
  color: #777;
}

#loaderForm > label, #loaderForm > input {
  display: block;
  margin: 1em;
}

#loaderForm > input {
  display: inline-block;
}

#loaderForm > fieldset > label {
  text-align: left;
  display: block;
}
.urlmode {
  font-size: .8em;
}
.urlmode, .urlmode > a {
  color: #888;
}
.urlmode > a:hover {
  color: #606060;
}

#shortcuts > table {
  background: #eee;
  margin: auto;
  padding: 0;
  border-spacing: 0;
}

#shortcuts > table tr:nth-child(even) {
  background: #ddd;
}

#shortcuts > table td {
  padding: .5em;
  padding-right: 2em;
}

#shortcuts > table td:first-child {
  text-align: right;
  font-weight: bold;
  padding-left: 2em;
  padding-right: .5em;
}

#searcher {
  background:#eee;
  padding: 0 10%;
  margin: 0;
  width: 80%
}

#searchInputMode, #searchResultList, #searchClose, #searchOptions {
  display: block;
  width: 100%;
  margin: .5em 0;
}
#searchInputMode {
  width: calc(100% - .5em);
}

#searchResultList {
  background: #ddd;
}

#searchResultList > a {
  display: block;
  margin: 0;
  padding: .2em .5em;
  border: 1px solid black;
  border-top: 0;
  text-decoration: none;
  color: black;
}

#searchResultList > a:first-child {
  border-top: 1px solid black;
}

#searchResultList > a:nth-child(even) {
  background: #eee;
}

b {
  background: #ffb;
}

#searchResultList > a:nth-child(even) > b {
  background: #ffc;
}

#searchResultList > a:hover {
  background: #e5efe5;
}

#searchResultList > a:focus, #searchResultList > a:active, #searchResultList > a#activeSearch {
  text-decoration: underline;
  color: #b81a2f;
}

#searchOptions > label {
  border-left: 1px solid black;
  padding: 0 .5em;
}

#searcher {
  flex-flow: column;
  height: 100vh;
}
#searchInputMode {
  flex: 0 1 unset;
}
#searchInputError {
  flex: 2 1 unset;
}
#searchOptions {
  flex: 3 1 unset;
}
#searchClose {
  flex: 4 1 unset;
}
#searchResultList {
  flex: 5 1 auto;
  overflow: auto;
}
  </style>
  
</head>
<body>
<noscript><p style="background:#eee;color:black;text-align:center;font-size:2em">Javascript must be enabled</p></noscript>

<img src="" class="imgWrapper"/>

<section id="info"></section>

<section id="goto">
  <form id="gotoForm">
    <p><label>Image: <input type="number" id="gotoImage" min="1"/> / <span id="gotoImageMax"></span></label> <span id="gotoImageInChapter"></span></p>
    <p><label>Chapter: <input type="number" id="gotoChapter" min="1"/> / <span id="gotoChapterMax"></span></label> <span id="gotoNameOfChapter"></span></p>
    <p><input type="button" value="Cancel (or escape)" id="gotoCancel"/> <input type="submit"/></p>
  </form>
</section>

<section id="loader">
  <form id="loaderForm">
    <label id="prefixLabel">Directory Prefix: <input id="prefix" type="text"/></label>
    <label>Directories: <input id="dirs" type="file" webkitdirectory="" multiple=""/></label>
    <p id="finalpath"></p>
    <fieldset>
      <legend>Mode:</legend>
      <label><input type="radio" id="mode_normal" name="mode" value="normal"/>Normal <span class="urlmode">(url: <a href="?mode=normal">?mode=normal</a>)</span></label>
      <label><input type="radio" id="mode_double" name="mode" value="double"/>Double page <span class="urlmode">(url: <a href="?mode=double">?mode=double</a>)</span></label>
      <label><input type="radio" id="mode_webtoon" name="mode" value="webtoon"/>Webtoon <span class="urlmode">(url: <a href="?mode=webtoon">?mode=webtoon</a>)</span></label>
      <label><input type="radio" id="mode_normal_or_double" name="mode" value="normal_or_double"/>Normal or Double page <span class="urlmode">(url: <a href="?mode=normal_or_double">?mode=normal_or_double</a>)</span></label>
      <label><input type="radio" id="mode_all" name="mode" value="all"/>All page <span class="urlmode">(url: <a href="?mode=all">?mode=all</a>)</span></label>
    </fieldset>
    <input type="submit"/>
    <input id="closeLoader" type="button" value="Cancel (or escape)"/>
  </form>
  <p id="repositoryUrl">
    <a href="https://jonathanpoelen.github.io/manga-viewer/shortcuts.html">Mouse / Keyboard Shortcuts</a><br/>
    Project: <a href="https://github.com/jonathanpoelen/manga-viewer">https://github.com/jonathanpoelen/manga-viewer</a>
  </p>
</section>

<section id="searcher">
  <input id="searchInputMode" type="text"/>
  <div id="searchInputError" type="text"></div>
  <section id="searchOptions">
    <select id="searchBy">
      <option>By Chapter</option>
      <option>By Image</option>
    </select>
    <label><input type="checkbox" id="searchThenBy">Then by Image</option></label>
    <label>Mode: <select id="searchMode">
      <option>Word</option>
      <option>Fuzzy</option>
      <option>Plain Text</option>
      <option>Regex</option>
    </select></label>
    <label>Case sensitivity: <select id="searchCaseSensitivity">
      <option>Sensitive</option>
      <option>Insensitive</option>
      <option>Upper Only</option>
    </select></label>
    <label>Accent sensitivity: <select id="searchAccentSensitivity">
      <option>Sensitive</option>
      <option>Insensitive</option>
      <option>Accent Only</option>
    </select></label>
  </section>
  <input id="searchClose" type="button" value="Cancel (or escape)"/>
  <div id="searchResultList"></div>
</section>

<section id="shortcuts"><table><tr><td>Space</td><td>pgdown_or_next </td></tr> <tr><td>Shift+Space</td><td>pgup_or_prev </td></tr> <tr><td>Space</td><td>restrict webtoon pgdown_or_next 98</td></tr> <tr><td>Space</td><td>restrict all pgdown_or_next 98</td></tr> <tr><td>Shift+Space</td><td>restrict webtoon pgup_or_prev 98</td></tr> <tr><td>Shift+Space</td><td>restrict all pgup_or_prev 98</td></tr> <tr><td>z</td><td>next -5</td></tr> <tr><td>x</td><td>next 5</td></tr> <tr><td>a</td><td>next -12</td></tr> <tr><td>s</td><td>next 12</td></tr> <tr><td>q</td><td>next -30</td></tr> <tr><td>w</td><td>next 30</td></tr> <tr><td>e</td><td>next -100</td></tr> <tr><td>r</td><td>next 100</td></tr> <tr><td>Left</td><td>prev </td></tr> <tr><td>Right</td><td>next </td></tr> <tr><td>Ctrl+Left</td><td>next -5</td></tr> <tr><td>Ctrl+Right</td><td>next 5</td></tr> <tr><td>Ctrl+Up</td><td>next 12</td></tr> <tr><td>Ctrl+Down</td><td>next -12</td></tr> <tr><td>&lt;</td><td>next_chap -1</td></tr> <tr><td>></td><td>next_chap 1</td></tr> <tr><td>|</td><td>prev </td></tr> <tr><td>c</td><td>pgup_or_prev </td></tr> <tr><td>v</td><td>prev </td></tr> <tr><td>b</td><td>pgup_or_prev </td></tr> <tr><td>.</td><td>prev </td></tr> <tr><td>/</td><td>pgdown_or_next </td></tr> <tr><td>m</td><td>rotate -90</td></tr> <tr><td>,</td><td>rotate 90</td></tr> <tr><td>g</td><td>goto </td></tr> <tr><td>^</td><td>goto 0</td></tr> <tr><td>$</td><td>goto -1</td></tr> <tr><td>h</td><td>mode webtoon</td></tr> <tr><td>j</td><td>mode double</td></tr> <tr><td>k</td><td>mode normal</td></tr> <tr><td>l</td><td>mode normal_or_double</td></tr> <tr><td>d</td><td>info </td></tr> <tr><td>o</td><td>info </td></tr> <tr><td>t</td><td>toggle_auto_scroll </td></tr> <tr><td>u</td><td>add_interval -25</td></tr> <tr><td>i</td><td>add_interval 25</td></tr> <tr><td>y</td><td>newtab </td></tr> <tr><td>Y</td><td>newtab foreground</td></tr> <tr><td>LeftClick</td><td>pgdown_or_next </td></tr> <tr><td>Shift+LeftClick</td><td>pgup_or_prev </td></tr> <tr><td>Ctrl+LeftClick</td><td>next_chap </td></tr> <tr><td>Ctrl+Shift+LeftClick</td><td>next_chap -1</td></tr> <tr><td>Alt+LeftClick</td><td>newtab </td></tr> <tr><td>AltGr+LeftClick</td><td>newtab </td></tr> <tr><td>@</td><td>mouse_assistance </td></tr> <tr><td>F1</td><td>shortcuts </td></tr> <tr><td>F8</td><td>search </td></tr> <tr><td>F10</td><td>open </td></tr> <tr><td>F6</td><td>save </td></tr> <tr><td>F7</td><td>load </td></tr></table></section>

<div id="mouseAssistance"><span></span><span></span><span></span><span></span></div>

<script type="text/javascript">
"use strict";

const defaultFileNameList = [
];

let longJumpSearchImg = 10;
let longJumpSearchChap = 5;

const urlParams = new URLSearchParams(window.location.search);
const originalModeName = urlParams.get("mode");
urlParams.delete("mode");

let ifile = +urlParams.values().next().value || 0;
const img = document.getElementsByTagName("img")[0];
const info = document.getElementById("info");
const body = document.documentElement;

const min = Math.min;
const max = Math.max;

let fileByFilename;
let filenames;
let nbFilename;
// chapterByIndexes: [{startIndex: from filenames, images: [filename...], ichap: Number}...]
// chapterByIndexes.length == nbFilename
let chapterByIndexes;
let startIndexByChapters;

const rotate = function(deg) {
  const r = img.getAttribute("style");
  if (r) {
    deg += Number(r.substring(25, r.length-4));
  }
  img.setAttribute("style", `transform:rotate(${deg}deg)`);
};

const openInNewTab = function(type) {
  mode.syncIFile();
  const url = filenames[ifile];
  if (type === 2) {
    window.open(url, url);
  }
  else {
    const a = document.createElement("a");
    a.href = url;
    document.body.appendChild(a);
    disableShortcuts();
    if (type === 0) {
      a.dispatchEvent(new MouseEvent("click", {ctrlKey: true}));
    }
    else {
      a.target = "_blank";
      a.dispatchEvent(new MouseEvent("click"));
    }
    enableShortcuts();
    document.body.removeChild(a);
  }
};

const toBottomOnLoad = function(image) {
  image.onload = function(e) {
    body.scrollTop = image.clientHeight;
    image.onload = undefined;
  };
};

const scrollOnImageAfterDelay = function(image, delay, addTop) {
  let trigger = false;

  const timerId = setTimeout(function() {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      image.onload = undefined;
    }
    else {
      trigger = true;
    }
  }, delay);

  image.onload = function(e) {
    if (trigger) {
      body.scrollTop = image.offsetTop + addTop;
      clearInterval(timerId);
    }
    else {
      trigger = true;
    }
    image.onload = undefined;
  };
};

const isLocalProtocol = (location.protocol === "file:");

const setImage = (function(){
  if (isLocalProtocol) {
    return function(img, filename) {
      img.src = filename;
    };
  }

  return function(img, filename) {
    if (fileByFilename) {
      const reader = new FileReader();
      reader.onload = (e) => {
        img.src = e.target.result;
      };
      reader.readAsDataURL(fileByFilename[filename]);
    }
    else {
      img.src = filename;
    }
  };
})();

const normalMode = {
  start: function() {
    setImage(img, filenames[ifile]);
  },
  stop: function() {},
  next: function() {
    if (ifile !== nbFilename) {
      setImage(img, filenames[++ifile]);
      body.scrollTop = 0;
    }
  },
  prev: function() {
    if (ifile) {
      setImage(img, filenames[--ifile]);
      toBottomOnLoad(img);
    }
  },
  advance: function(x) {
    ifile = max(0, min(ifile+x, nbFilename-1));
    setImage(img, filenames[ifile]);
    body.scrollTop = 0;
  },
  advanceChap: function(x) {
    const chap = chapterByIndexes[ifile];
    const ichap = max(0, min(chap.ichap + x, startIndexByChapters.length-1));
    ifile = startIndexByChapters[ichap];
    // when last chapter, go to end image
    if (x > 0 && ichap === chap.ichap) {
      ifile += chap.images.length - 1;
    }
    setImage(img, filenames[ifile]);
    body.scrollTop = 0;
  },
  syncIFile: function() {},
};

const doublePageMode = {
  start: function() {
    this.db = false;
  },
  stop: function() {},
  next: function() {
    if (this.dp) {
      if (ifile === nbFilename) {
        return;
      }
      setImage(img, filenames[++ifile]);
    }
    this.dp = !this.dp;
    body.scrollTop = 0;
  },
  prev: function() {
    if (this.dp) {
      if (!ifile) {
        return;
      }
      setImage(img, filenames[--ifile]);
      toBottomOnLoad(img);
    }
    else {
      body.scrollTop = img.clientHeight;
    }
    this.dp = !this.dp;
  },
  advance: function(x) {
    this.db = false;
    normalMode.advance(x);
  },
  advanceChap: function(x) {
    this.db = false;
    normalMode.advanceChap(x);
  },
  syncIFile: function() {},
};

const isSinglePageImg = function() {
  return img.width <= img.height;
};

const normalOrDoublePageMode = {
  start: function() {
    doublePageMode.start();
  },
  stop: function() {},
  next: function() {
    if (isSinglePageImg()) {
      normalMode.next();
    }
    else {
      doublePageMode.next();
    }
  },
  prev: function() {
    if (isSinglePageImg()) {
      normalMode.prev();
    }
    else {
      doublePageMode.prev();
    }
  },
  advance: function(x) {
    doublePageMode.advance(x);
  },
  advanceChap: function(x) {
    doublePageMode.advanceChap(x);
  },
  syncIFile: function() {},
};

const appendImages = function(elem, urls, startIndex) {
  const nUrl = urls.length;
  for (let i = 0; i < nUrl; ++i, ++startIndex) {
    const img = document.createElement("img");
    setImage(img, urls[i]);
    img.dataset.i = startIndex;
    elem.appendChild(img);
  }
};

const removeChildren = function(elem) {
  while (elem.lastChild) {
    elem.lastChild.remove();
  }
}

const groupPageModeBase = {
  eimgs: (function(){
    const div = document.createElement("div");
    div.className = "imgWrapper";
    return div;
  })(),
  syncIFile: function() {
    const img = document.elementFromPoint(body.clientWidth / 2, 10);
    const i = img.dataset.i;
    if (i) {
      ifile = +i;
    }
  },
  _start: function(chapterByIndexes, startIndexByChapters, imageLimit) {
    if (0 === filenames.length) {
      return;
    }

    if (!imageLimit) {
      this.chapterByIndexes = chapterByIndexes;
    }
    else if (imageLimit in this.chapterByIndexesByImageLimits) {
      this.chapterByIndexes = this.chapterByIndexesByImageLimits[imageLimit];
    }
    else {
      const chaps = new Array(filenames.length);
      let startIndex = 0;
      for (const chapIndex of startIndexByChapters) {
        const images = chapterByIndexes[chapIndex].images;
        const imageLen = images.length;
        if (imageLen > imageLimit) {
          for (let i = 0; i < imageLen; i += imageLimit) {
            const subImages = images.slice(i, i + imageLimit);
            const subImageLen = subImages.length;
            chaps.fill({startIndex, images: subImages}, startIndex, startIndex + subImageLen);
            startIndex += subImageLen;
          }
        }
        else {
          chaps.fill({startIndex, images}, startIndex, startIndex + imageLen);
          startIndex += imageLen;
        }
      }
      this.chapterByIndexesByImageLimits[imageLimit] = chaps;
      this.chapterByIndexes = chaps;
    }

    document.body.removeChild(img);
    document.body.appendChild(this.eimgs);
    this.updateChapter();
    const i = this.currentChapter.startIndex;
    const image = this.eimgs.childNodes[ifile-i];
    // TODO calculate the scroll in relation to the position of the image
    scrollOnImageAfterDelay(image, 100, 0);
  },
  updateChapter: function(){
    const chap = this.chapterByIndexes[ifile];
    this.currentChapter = chap;
    removeChildren(this.eimgs);
    appendImages(this.eimgs, chap.images, chap.startIndex);
  },
  stop: function() {
    if (0 === filenames.length) {
      return;
    }
    this.syncIFile();
    setImage(img, filenames[ifile]);
    document.body.removeChild(this.eimgs);
    document.body.appendChild(img);
    // TODO calculate the scroll in relation to the position of the image
    body.scrollTop = 0;
  },
  next: function() {
    const i = this.currentChapter.startIndex + this.currentChapter.images.length;
    if (i !== nbFilename) {
      ifile = i;
      this.updateChapter();
      body.scrollTop = 0;
    }
  },
  prev: function() {
    if (this.currentChapter.startIndex) {
      ifile = this.currentChapter.startIndex - 1;
      this.updateChapter();
      const image = this.eimgs.lastChild;
      scrollOnImageAfterDelay(image, 100, 100);
    }
  },
  advance: function(x) {
    this.syncIFile();
    ifile = max(0, min(ifile+x, nbFilename-1));
    const chap = this.chapterByIndexes[ifile];
    if (this.currentChapter === chap) {
      body.scrollTop = this.eimgs.children[ifile - chap.startIndex].offsetTop;
    }
    else {
      body.scrollTop = 0;
      this.currentChapter = chap;
      removeChildren(this.eimgs);
      appendImages(this.eimgs, chap.images, chap.startIndex);
      const image = this.eimgs.childNodes[ifile-chap.startIndex];
      scrollOnImageAfterDelay(image, 100, 0);
    }
  },
  advanceChap: function(x) {
    this.syncIFile();
    let chap = chapterByIndexes[this.chapterByIndexes[ifile].startIndex];
    const prevIChap = chap.ichap;
    const ichap = max(0, min(prevIChap + x, startIndexByChapters.length-1));
    ifile = startIndexByChapters[ichap];
    // when last chapter, go to end image
    if (x > 0 && ichap === prevIChap) {
      ifile += chap.images.length - 1;
    }
    chap = this.chapterByIndexes[ifile];
    body.scrollTop = 0;
    this.currentChapter = chap;
    removeChildren(this.eimgs);
    appendImages(this.eimgs, chap.images, chap.startIndex);
    const image = this.eimgs.childNodes[ifile-chap.startIndex];
    scrollOnImageAfterDelay(image, 100, 0);
  },
};

const webtoonMode = Object.assign({
  chapterByIndexesByImageLimits: {},
  start: function(imageLimit) {
    this._start(chapterByIndexes, startIndexByChapters, imageLimit);
  },
}, groupPageModeBase);

const allMode = Object.assign({
  chapterByIndexesByImageLimits: {},
  start: function(imageLimit) {
    this._start([{startIndex: 0, images: filenames}], [0], imageLimit);
  },
}, groupPageModeBase);

const modeToModeName = function(mode) {
  switch (mode) {
    case normalMode: return "normal";
    case doublePageMode: return "double";
    case webtoonMode: return "webtoon";
    case normalOrDoublePageMode: return "normal_or_double";
    case allMode: return "all";
  }
}

const modeNameToMode = function(name) {
  switch (name) {
    case "normal": return normalMode;
    case "double": return doublePageMode;
    case "webtoon": return webtoonMode;
    case "normal_or_double": return normalOrDoublePageMode;
    case "all": return allMode;
  }
}

let mode = modeNameToMode(originalModeName) || normalMode;
let currentImageLimit = 0;
let bottomPixelDistance = 20;

const downOrNext = function(d, height) {
  if (body.scrollTop + body.clientHeight >= body.scrollHeight - d) {
    mode.next();
  }
  else {
    body.scrollTop += height || body.clientHeight;
  }
};

const upOrPrev = function(height) {
  if (body.scrollTop === 0) {
    mode.prev();
  }
  else {
    body.scrollTop -= height || body.clientHeight;
  }
};

// auto-scroll
//@{
let autoScrollDelay = null;
let autoScrollTimerId = null;

const startAutoScroll = function(delay) {
  console.log(`delay: ${delay}`);
  clearInterval(autoScrollTimerId);
  autoScrollDelay = delay;
  autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
};

const toggleAutoScroll = function(delay) {
  if (autoScrollDelay === null) {
    startAutoScroll(delay);
  }
  else if (autoScrollTimerId === null) {
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  else {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = null;
  }
};

const addAutoScrollInterval = function(delay) {
  autoScrollDelay = max(1, (autoScrollDelay || 800) + delay);
  if (autoScrollTimerId !== null) {
    clearInterval(autoScrollTimerId);
    autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
  }
  console.log(`autoScrollDelay: ${autoScrollDelay} (+${delay})`);
};
//@}

const closeEvent = {key: "Escape"};
const isCloseEvent = (e) => e.key === "Escape";

const osd = (function() {
  let resumeAutoScroll = false;
  let isClosable;
  let closeAction;
  const forceCloseOSD = function(ev) {
    window.removeEventListener("keydown", removeOSD, true);
    if (resumeAutoScroll) {
      resumeAutoScroll = false;
      if (autoScrollTimerId === null) {
        autoScrollTimerId = setInterval(downOrNext, autoScrollDelay, bottomPixelDistance);
      }
    }
    closeAction(ev);
  };
  const removeOSD = function(ev) {
    if (isClosable(ev)) {
      forceCloseOSD(ev);
    }
  };
  const open = function(isClosableFn, closeActionFn) {
    if (autoScrollTimerId !== null) {
      clearInterval(autoScrollTimerId);
      autoScrollTimerId = null;
      resumeAutoScroll = true;
    }

    isClosable = isClosableFn;
    closeAction = closeActionFn;
    window.addEventListener("keydown", removeOSD, true);
  }
  open.close = forceCloseOSD;
  return open;
})();

const showImageInfo = function() {
  mode.syncIFile();
  const chap = chapterByIndexes[ifile];
  const scrollInfo = (autoScrollTimerId !== null) ? `[auto-scroll: ${autoScrollDelay}ms]` : "";
  info.textContent = `[${ifile+1}/${nbFilename}][Chapter: \
${chap.ichap+1}/${startIndexByChapters.length}][Img: ${ifile-chap.startIndex+1}/${chap.images.length}]${scrollInfo} \
${filenames[ifile]}`;
  info.style.display = "block";
  info.style.top = `${body.scrollTop}px`;
  disableShortcuts();
  osd(() => true, () => {
    enableShortcuts();
    info.style.display = "none";
  });
};

const showGoto = (function() {
  const goto = document.getElementById("goto");
  const gotoForm = document.getElementById("gotoForm");
  const gotoCancel = document.getElementById("gotoCancel");
  const gotoImageInput = document.getElementById("gotoImage");
  const gotoChapterInput = document.getElementById("gotoChapter");
  const gotoImageMax = document.getElementById("gotoImageMax");
  const gotoChapterMax = document.getElementById("gotoChapterMax");
  const gotoImageInChapter = document.getElementById("gotoImageInChapter");
  const gotoNameOfChapter = document.getElementById("gotoNameOfChapter");

  let lastInput = gotoImageInput;

  const validateGoto = function(e, input) {
    e.preventDefault();
    e.stopImmediatePropagation();

    lastInput = input;
    const n = input.value - 1;
    if (input === gotoImageInput) {
      mode.advance(n - ifile);
    }
    else {
      mode.advanceChap(n - chapterByIndexes[ifile].ichap);
    }
    osd.close(closeEvent);
  };

  gotoForm.addEventListener("submit", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    let elem = document.activeElement;
    if (elem !== gotoImageInput && elem !== gotoChapterInput) {
      elem = lastInput;
    }
    validateGoto(e, lastInput);
  }, false);

  gotoCancel.addEventListener("click", function(e) {
    validateGoto(e, lastInput);
  }, false);

  let chapStartIndex;

  const updateLastInput = function(e) {
    lastInput = e.target;
    e.preventDefault();
    e.stopImmediatePropagation();
  };

  const updateChapElement = function() {
    let filename = filenames[chapStartIndex];

    const index = filename.lastIndexOf("/");
    if (index !== -1) {
      filename = filename.substring(0, index);
    }
    gotoNameOfChapter.textContent = `(dirname: ${filename})`;
  };

  const updateImageElement = function() {
    const n = +gotoImageInput.value;
    const currentChap = chapterByIndexes[n-1];
    const startIndex = currentChap.startIndex;

    gotoImageInChapter.textContent = `(in the chapter: ${n-startIndex}/${currentChap.images.length})`;

    return startIndex;
  };

  gotoImageInput.addEventListener("change", function(e) {
    updateLastInput(e);
    const startIndex = updateImageElement();
    if (startIndex !== chapStartIndex) {
      chapStartIndex = startIndex;
      gotoChapterInput.value = chapterByIndexes[startIndex].ichap+1;
      updateChapElement();
    }
  });
  gotoChapterInput.addEventListener("change", function(e) {
    chapStartIndex = startIndexByChapters[gotoChapterInput.value-1];
    updateLastInput(e);
    updateChapElement();
    updateImageElement();
    gotoImageInput.value = chapterByIndexes[chapStartIndex].startIndex + 1;
  });

  return function() {
    const chap = chapterByIndexes[ifile];
    chapStartIndex = chap.startIndex;
    gotoImageInput.max = nbFilename;
    gotoImageInput.value = ifile+1;
    gotoChapterInput.value = chap.ichap+1;
    gotoChapterInput.max = startIndexByChapters.length;
    gotoImageMax.textContent = nbFilename;
    gotoChapterMax.textContent = startIndexByChapters.length;
    updateImageElement();
    updateChapElement();
    goto.style.display = "block";
    goto.style.top = `${body.scrollTop}px`;
    lastInput.focus();
    disableShortcuts();
    osd(isCloseEvent, function() {
      goto.style.display = "none";
      enableShortcuts();
      gotoImageInput.blur();
      gotoChapterInput.blur();
    });
  };
})();

const gotoImage = function(i) {
  if (i < 0) {
    i += nbFilename;
  }
  mode.advance(i - ifile);
};

const modal = function(isClosableFn, closeActionFn) {
  const img = document.getElementsByClassName("imgWrapper")[0];
  const display = img.style.display;
  const scrollTop = body.scrollTop;
  body.scrollTop = 0;
  img.style.display = "none";
  disableShortcuts();
  osd(isClosableFn, function(){
    img.style.display = display;
    body.scrollTop = scrollTop;
    enableShortcuts();
    closeActionFn();
  });
};
modal.close = osd.close;

const showShorcuts = (function() {
  const shortcutsDesc = document.getElementById("shortcuts");
  return function() {
    modal((e) => {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "PageDown":
        case "PageUp":
        case "Home":
        case "End":
        case "Ctrl":
        case "OS":
        case "Control":
        case "Shift":
        case "Alt":
        case "AltGraph":
        case " ":
        // browser search shortcut
        case "/":
        case "f"/* + ctrl */:
        case "F3":
        // fullscreen
        case "F11":
        // dev
        case "F12":
          return false;
      }
      return true;
    }, () => {
      shortcutsDesc.style.display = "none";
    });
    shortcutsDesc.style.display = "block";
  }
})();

const showLoader = (function() {
  const loader = document.getElementById("loader");
  const closeLoader = document.getElementById("closeLoader");
  const loaderForm = document.getElementById("loaderForm");
  const prefixLabel = document.getElementById("prefixLabel");
  const prefixElement = document.getElementById("prefix");
  const dirsElement = document.getElementById("dirs");
  const pathElement = document.getElementById("finalpath");
  const modes = {
    normal: document.getElementById("mode_normal"),
    double: document.getElementById("mode_double"),
    webtoon: document.getElementById("mode_webtoon"),
    normal_or_double: document.getElementById("mode_normal_or_double"),
    all: document.getElementById("mode_all"),
  }
  const regSplit = /([0-9]+(?:\.[0-9]+)?|[^0-9]+)/g;
  const regDigit = /^[0-9]/;

  const getPrefix = function() {
    let prefix = prefixElement.value;
    if (prefix && !prefix.endsWith("/")) {
      prefix += "/";
    }
    return prefix;
  };

  const updateFinalPath = function() {
    const file = dirsElement.files[0];
    if (file) {
      const path = document.createElement("b");
      path.textContent = getPrefix() + file.webkitRelativePath;
      pathElement.textContent = "Final path of one of the files: ";
      pathElement.appendChild(path);
    }
  };

  dirsElement.addEventListener("change", updateFinalPath, true);
  prefixElement.addEventListener("keyup", updateFinalPath, true);
  prefixElement.addEventListener("input", function(e) {
    // update only when pasted from clipboard
    if (e.inputType === "insertFromPaste") updateFinalPath();
  }, true);

  loaderForm.addEventListener("submit", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();

    const files = dirsElement.files;

    let newMode;
    for (const modeName in modes) {
      if (modes[modeName].checked) {
        const selectedMode = modeNameToMode(modeName);
        if (selectedMode !== mode) {
          mode.stop();
          newMode = selectedMode;
          mode = newMode;
        }
        break;
      }
    }

    const filenameDatas = [];
    for (let i = 0; i < files.length; ++i) {
      const parts = [];
      const file = files[i];
      const path = file.webkitRelativePath;
      // split by string and number
      for (const m of path.matchAll(regSplit)) {
        parts.push(regDigit.test(m[0]) ? Number(m[0]) : m[0]);
      }
      filenameDatas.push([path, parts, file]);
    }

    // natural sort
    filenameDatas.sort(function(a, b) {
      a = a[1];
      b = b[1];
      const alen = a.length;
      const blen = b.length;
      if (alen < blen) return -1;
      if (alen > blen) return 1;
      for (let i = 0; i < alen; ++i) {
        const x = a[i];
        const y = b[i];
        if (x < y) return -1;
        if (x > y) return 1;
      }
      return 0;
    });

    if (isLocalProtocol) {
      const prefix = getPrefix();
      if (localStorage) {
        localStorage.setItem("prefix", prefix);
      }

      const filenameLength = filenameDatas.length;
      for (let i = 0; i < filenameLength; ++i) {
        filenameDatas[i] = prefix + filenameDatas[i][0];
      }

      initFilenames(filenameDatas);
    }
    else {
      const filenameLength = filenameDatas.length;
      const filenames = new Array(filenameLength);
      const fileByFilename = {};
      for (let i = 0; i < filenameLength; ++i) {
        filenames[i] = filenameDatas[i][0];
        fileByFilename[filenames[i]] = filenameDatas[i][2];
      }

      initFilenames(filenames, fileByFilename);
    }

    if (newMode) {
      updateShortcuts(mode);
    }

    modal.close(closeEvent);
    body.scrollTop = 0;
  }, true);

  closeLoader.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    modal.close(closeEvent);
  }, true);

  return function() {
    modal(isCloseEvent, () => {
      loader.style.display = "none";
      prefixElement.blur();
    });
    prefixLabel.style.display = isLocalProtocol ? "inline" : "none";
    pathElement.style.display = isLocalProtocol ? "block" : "none";
    loader.style.display = "block";
    if (isLocalProtocol) {
      prefixElement.value = (localStorage && localStorage.getItem("prefix")) || "";
      updateFinalPath();
      prefixElement.focus();
    }
    modes[modeToModeName(mode)].checked = true;
  }
})();

const SEARCH_BY_CHAPTER         = 0b0000_000_000_000_001;
const SEARCH_BY_IMAGE           = 0b0000_000_000_000_010;
const SEARCH_BY_IMAGE_IN_CHAP   = 0b0000_000_000_000_100;
const SEARCH_BY_MASK            = 0b0000_000_000_000_111;

const SEARCH_THEN_BY_IMAGE      = 0b0000_000_000_001_000;
const SEARCH_THEN_BY_MASK       = 0b0000_000_000_001_000;

const SEARCH_CASE_SENSITIVE     = 0b000_000_001_000_000;
const SEARCH_CASE_INSENSITIVE   = 0b000_000_010_000_000;
const SEARCH_UPPERCASE_ONLY     = 0b000_000_100_000_000;
const SEARCH_CASE_SENSITIVITY_MASK = 0b0000_000_111_000_000;

const SEARCH_ACCENT_SENSITIVE   = 0b0000_001_000_000_000;
const SEARCH_ACCENT_INSENSITIVE = 0b0000_010_000_000_000;
const SEARCH_ACCENT_ONLY        = 0b0000_100_000_000_000;
const SEARCH_ACCENT_SENSITIVITY_MASK = 0b0000_111_000_000_000;

const SEARCH_MODE_WORD          = 0b0001_000_000_000_000;
const SEARCH_MODE_FUZZY         = 0b0010_000_000_000_000;
const SEARCH_MODE_TEXT          = 0b0100_000_000_000_000;
const SEARCH_MODE_REGEX         = 0b1000_000_000_000_000;
const SEARCH_MODE_MASK          = 0b1111_000_000_000_000;

const showSearcher = (function() {
  // Testable searcher
  // @{

  const removeAccents = function(str) {
    // remove diacritics
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  };

  const createDelegateSearcher = function(options, str, finder) {
    switch (options & (SEARCH_CASE_SENSITIVITY_MASK | SEARCH_ACCENT_SENSITIVITY_MASK)) {
      case SEARCH_CASE_SENSITIVE   | SEARCH_ACCENT_SENSITIVE:
        return function(si) { return finder(str, si.str, si); };
      case SEARCH_CASE_SENSITIVE   | SEARCH_ACCENT_INSENSITIVE:
        str = removeAccents(str);
        return function(si) { return finder(str, si.unaccentedStr, si); };
      case SEARCH_CASE_INSENSITIVE | SEARCH_ACCENT_SENSITIVE:
        str = str.toUpperCase();
        return function(si) { return finder(str, si.upperStr, si); };
      case SEARCH_CASE_INSENSITIVE | SEARCH_ACCENT_INSENSITIVE:
        str = str.toUpperCase();
        str = removeAccents(str);
        return function(si) { return finder(str, si.unaccentedUpperStr, si); };
    }
  };

  const createFuzzySearcher = function(options, c) {
    if (options & SEARCH_UPPERCASE_ONLY) {
      const upper = c.toUpperCase();
      options &= ~SEARCH_CASE_SENSITIVITY_MASK;
      options |= (upper === c) ? SEARCH_CASE_SENSITIVE : SEARCH_CASE_INSENSITIVE;
    }

    if (options & SEARCH_ACCENT_ONLY) {
      const accent = removeAccents(c);
      options &= ~SEARCH_ACCENT_SENSITIVITY_MASK;
      options |= (accent === c) ? SEARCH_ACCENT_INSENSITIVE : SEARCH_ACCENT_SENSITIVE;
    }

    return createDelegateSearcher(options, c, function(c, str, si) {
      si.lengthFound = 1;
      return str.indexOf(c, si.lastIndex+1);
    });
  };

  const textIndexOf = function(searchValue, str, si) {
    const index = si.lastIndex + si.lengthFound + (si.lastIndex === -1);
    si.lengthFound = searchValue.length;
    return str.indexOf(searchValue, index);
  };

  const textStartsWith = function(searchValue, str, si) {
    const index = si.lastIndex + si.lengthFound;
    si.lengthFound += searchValue.length;
    return str.startsWith(searchValue, index) ? si.lastIndex : -1;
  };

  const createTextSearcher = function(options, str, extendStr) {
    const searcher = createDelegateSearcher(options, str, extendStr ? textStartsWith : textIndexOf);
    if (searcher) {
      return searcher;
    }

    // options contains SEARCH_UPPERCASE_ONLY and/or SEARCH_ACCENT_ONLY

    const caseSensitivity = (options & SEARCH_CASE_SENSITIVITY_MASK);
    const accentSensitivity = (options & SEARCH_ACCENT_SENSITIVITY_MASK);

    const upper = str.toUpperCase();
    const unaccented = removeAccents(upper);

    const getState = function(i) {
      return ((upper[i] === str[i])
              ? ((caseSensitivity === SEARCH_UPPERCASE_ONLY)
                 ? SEARCH_CASE_SENSITIVE
                 : caseSensitivity
                )
              : ((caseSensitivity === SEARCH_UPPERCASE_ONLY)
                 ? SEARCH_CASE_INSENSITIVE
                 : caseSensitivity
                )
             )
           | ((unaccented[i] === upper[i])
              ? ((accentSensitivity === SEARCH_ACCENT_ONLY)
                 ? SEARCH_ACCENT_INSENSITIVE
                 : accentSensitivity
                )
              : ((accentSensitivity === SEARCH_ACCENT_ONLY)
                 ? SEARCH_ACCENT_SENSITIVE
                 : accentSensitivity
                )
             )
    };

    const searchers = [];
    // split chain by state
    {
      const len = str.length;
      let start = 0;
      let state = getState(0);
      let newState;
      let i;

      const push = function() {
        searchers.push(createDelegateSearcher(state,
                                              str.substring(start, i),
                                              extendStr ? textStartsWith : textIndexOf));
        extendStr = false;
      };

      for (i = 1; i < len; ++i) {
        newState = getState(i);
        if (newState !== state) {
          push();
          state = newState;
          start = i;
        }
      }
      push();
    }

    return function(si) {
      let index = -1;
      for (const searcher of searchers) {
        index = searcher(si);
        if (index === -1) {
          return -1;
        }
      }
      return index;
    }
  };

  const createWordSearchers = function(options, str, i) {
    const searchers = [];
    let startedWord = (i === 0 || str[i - 1] === " ");

    while (true) {
      while (i < str.length && str[i] === " ") {
        ++i;
        startedWord = true;
      }

      if (i === str.length) {
        break;
      }

      const endWord = str.indexOf(" ", i);
      const word = str.substring(i, endWord === -1 ? undefined : endWord);
      searchers.push(createTextSearcher(options, word, !startedWord));

      if (endWord === -1) {
        break;
      }
      i = endWord;
    }

    return searchers;
  };

  const searchRegIndex = function(str, si, reg) {
    const m = str.match(reg);
    if (m) {
      si.lengthFound = m[0].length;
      return m.index;
    }
    return -1;
  };

  const createRegexSearcher = function(options, pattern) {
    const isCaseInsensitive = options & (SEARCH_UPPERCASE_ONLY | SEARCH_CASE_INSENSITIVE);
    const isAccentInsensitive = options & (SEARCH_ACCENT_ONLY | SEARCH_ACCENT_INSENSITIVE);

    const reg = new RegExp(isAccentInsensitive ? removeAccents(pattern) : pattern,
                           isCaseInsensitive ? "i" : "");
    if (isAccentInsensitive) {
      return function(si) { return searchRegIndex(si.unaccentedStr, si, reg); };
    }
    return function(si) { return searchRegIndex(si.str, si, reg); };
  };

  const filter = function(datas, searcher) {
    let newLength = 0;
    for (const si of datas) {
      const index = searcher(si);
      if (index !== -1) {
        si.lastIndex = index;
        si.fragments.push({index, lengthFound: si.lengthFound});
        datas[newLength] = si;
        ++newLength;
      }
    }
    datas.length = newLength;
  };

  // @}

  const searcherElement = document.getElementById("searcher");
  const input = document.getElementById("searchInputMode");
  const searchInputErrorElement = document.getElementById("searchInputError");
  const searchByElement = document.getElementById("searchBy");
  const searchThenByElement = document.getElementById("searchThenBy");
  const searchCaseSensitivityElement = document.getElementById("searchCaseSensitivity");
  const searchAccentSensitivityElement = document.getElementById("searchAccentSensitivity");
  const searchModeElement = document.getElementById("searchMode");
  const searchCloseElement = document.getElementById("searchClose");
  const searchResultListElement = document.getElementById("searchResultList");

  let strings;
  let results;
  let previousText;
  let activeElement;
  let options;

  const resetDOM = function() {
    removeChildren(searchResultListElement);

    // create results and DOM elements
    const len = strings.length;
    results = new Array(len);
    for (let i = 0; i < len; ++i) {
      const str = strings[i];
      const elem = searchResultListElement.appendChild(document.createElement("a"));
      elem.appendChild(document.createTextNode(str));
      elem.setAttribute("href", "#");
      elem.dataset.index = i;
      const unaccentedStr = removeAccents(str);
      const upperStr = str.toUpperCase();
      const unaccentedUpperStr = unaccentedStr.toUpperCase();
      results[i] = {str, upperStr, unaccentedStr, unaccentedUpperStr, lastIndex: -1, lengthFound: 0, elem, fragments: []};
    }
  };

  const resetState = function() {
    resetDOM();
    // state for updateResults()
    previousText = "";
  };

  const setActiveSearch = function(i) {
    if (activeElement) {
      activeElement.removeAttribute("id");
    }
    activeElement = results[i].elem;
    activeElement.setAttribute("id", "activeSearch");
    updateResultScroll();
  }

  const userActiveIndex = function() {
    return (options & SEARCH_BY_CHAPTER) ? chapterByIndexes[ifile].ichap : ifile;
  };

  const updateFragmentsDisplay = function() {
    removeChildren(searchResultListElement);
    for (let i = 0; i < results.length; ++i) {
      const result = results[i];
      const fragments = result.fragments;
      result.fragments = [];

      let ifrag = 0;

      // merge fragments [idx: 1, len:1][idx: 2, len:1] = [idx: 1, len:2]
      {
        const fragLen = fragments.length;
        for (let i = 1; i < fragLen; ++i) {
          const prev = fragments[ifrag];
          const fragment = fragments[i];
          if (prev.index + prev.lengthFound === fragment.index) {
            prev.lengthFound += fragment.lengthFound;
          }
          else {
            ++ifrag;
          }
        }
      }

      const elem = result.elem;
      const str = result.str;

      // add first fragment to previous element
      const lastElem = elem.lastChild;
      if (lastElem.previousSibling?.firstChild && str.length - lastElem.textContent.length >= fragments[0].index) {
        const fragment = fragments[0];
        const delta = str.length - lastElem.textContent.length - fragment.index;
        const startIndex = fragment.index + delta;
        const endIndex = fragment.index + fragment.lengthFound;
        lastElem.previousSibling.firstChild.textContent += str.substring(startIndex, endIndex);
        lastElem.textContent = str.substring(endIndex);
        ++ifrag;
      }

      const fragLen = fragments.length;
      for (; ifrag < fragLen; ++ifrag) {
        const fragment = fragments[ifrag];
        const lastElem = elem.lastChild;
        const strPart = lastElem.textContent;
        const splitIndex1 = fragment.index - (str.length - strPart.length);
        const splitIndex2 = splitIndex1 + fragment.lengthFound;
        const b = elem.appendChild(document.createElement("b"));
        b.textContent = strPart.substring(splitIndex1, splitIndex2);
        elem.appendChild(document.createTextNode(strPart.substring(splitIndex2)));
        lastElem.textContent = strPart.substring(0, splitIndex1);
      }
      searchResultListElement.appendChild(elem);
    }
  }

  const updateRangeDisplay = function() {
    removeChildren(searchResultListElement);
    for (let i = 0; i < results.length; ++i) {
      const result = results[i];
      const elem = result.elem;
      const str = result.str;
      const index = result.lastIndex;
      const len = result.lengthFound;
      removeChildren(elem);
      elem.appendChild(document.createTextNode(str.substr(0, index)));
      elem.appendChild(document.createElement("b")).textContent = str.substr(index, len);
      elem.appendChild(document.createTextNode(str.substr(index+len)));
      searchResultListElement.appendChild(elem);
    }
  }

  const updateResultScroll = function() {
    const firstElementChild = searchResultList.firstElementChild;
    if (!firstElementChild) {
      return;
    }
    const rect = activeElement.getBoundingClientRect();
    const outerRect = searchResultList.getBoundingClientRect();
    const firstRect = firstElementChild.getBoundingClientRect();
    searchResultList.scrollTop = rect.y - firstRect.y - outerRect.height / 2;
  };

  const updateResults = function() {
    const text = input.value;

    // if the character is not added at the end of the text (unoptimized case)
    if (!text.startsWith(previousText)) {
      const i = activeElement.parentNode ? activeElement.dataset.index : userActiveIndex();
      resetState();
      activeElement = results[i].elem;
      activeElement.setAttribute("id", "activeSearch");

      if (text.length === 0) {
        return;
      }
    }
    else if (text.length === previousText.length) {
      return;
    }

    switch (options & SEARCH_MODE_MASK) {
      case SEARCH_MODE_FUZZY:
        for (let i = previousText.length; i < text.length; ++i) {
          filter(results, createFuzzySearcher(options, text[i]));
        }
        updateFragmentsDisplay();
        break;

      case SEARCH_MODE_WORD:
        const searchers = createWordSearchers(options, text, previousText.length);
        if (searchers.length !== 0) {
          for (const searcher of searchers) {
            filter(results, searcher);
          }
          updateFragmentsDisplay();
        }
        break;

      case SEARCH_MODE_TEXT:
        if (previousText.length !== 0) {
          filter(results, createTextSearcher(options, text.substr(previousText.length), true));
        }
        else {
          filter(results, createTextSearcher(options, text, false));
        }
        updateRangeDisplay();
        break;

      case SEARCH_MODE_REGEX:
        try {
          filter(results, createRegexSearcher(options, text));
        }
        catch (ex) {
          if (ex instanceof SyntaxError) {
            searchInputErrorElement.textContent = ex;
            searchInputErrorElement.style.display = "block";
            return;
          }
          throw ex;
        }
        searchInputErrorElement.style.display = "none";
        updateRangeDisplay();
        break;
    }

    previousText = text;

    // if activeElement is not in the DOM
    if (!activeElement.parentNode && results[0]) {
      activeElement = results[0].elem;
      activeElement.setAttribute("id", "activeSearch");
    }

    updateResultScroll();
  };


  searchCloseElement.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    modal.close(closeEvent);
  }, true);

  let savedIndex = null;
  const validateItem = function(i) {
    if (options & SEARCH_BY_IMAGE_IN_CHAP) {
      // /!\ i is a string
      i = (i|0) + savedIndex;
      savedIndex = null;
    }
    else if (options & SEARCH_BY_CHAPTER) {
      const startIndex = startIndexByChapters[i];
      if (savedIndex === null && (options & SEARCH_THEN_BY_IMAGE)) {
        input.value = "";
        activeElement = null;
        options |= SEARCH_BY_IMAGE_IN_CHAP;
        savedIndex = startIndex;
        initImageStringsOfChapIndex(startIndex);
        resetState();
        setActiveSearch(chapterByIndexes[ifile].startIndex === startIndex ? ifile - startIndex : 0);
        return;
      }
      i = startIndex;
    }
    mode.advance(i - ifile);
    modal.close(closeEvent);
  };

  input.addEventListener("keyup", updateResults, true);
  input.addEventListener("keydown", function(e) {
    switch (e.key) {
      case "ArrowUp":
      case "ArrowDown":
      case "PageUp":
      case "PageDown": {
        e.preventDefault();
        e.stopImmediatePropagation();

        if (results.length === 0) {
          return;
        }

        // if activeElement is in the DOM
        if (activeElement.parentNode) {
          const isUp = (e.key === "ArrowUp" || e.key === "PageUp");
          const step = (e.key === "PageUp" || e.key === "PageDown")
            ? ((options & SEARCH_BY_IMAGE) ? longJumpSearchImg : longJumpSearchChap)
            : 1;
          let next = activeElement;
          for (let i = 0; i < step; ++i) {
            next = isUp ? next.previousSibling : next.nextSibling;
            // circular list, go to top/bottom
            if (!next) {
              next = results[isUp ? results.length - 1 : 0].elem;
            }
          }
          activeElement.removeAttribute("id");
          activeElement = next;
        }
        else {
          activeElement = results[0].elem;
        }
        activeElement.setAttribute("id", "activeSearch");
        updateResultScroll();
        break;
      }

      // validate element
      case "Enter": {
        e.preventDefault();
        e.stopImmediatePropagation();

        let i;
        if (activeElement.parentNode) {
          i = activeElement.dataset.index;
        }
        else if (results.length !== 0) {
          i = results[0].elem.dataset.index;
        }
        else {
          return;
        }

        validateItem(i);
        break;
      }
    }
  }, true);

  input.addEventListener("input", function(e) {
    // update when pasted
    if (e.inputType === "insertFromPaste") {
      e.preventDefault();
      e.stopImmediatePropagation();
      updateResults();
    }
  }, true);

  searchResultListElement.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    let elem = e.target;
    if (elem.tagName === "B") {
      elem = elem.parentNode;
    }
    validateItem(elem.dataset.index);
  });

  const searchCommonPrefixLength = function(strings) {
    const firstString = strings[0];
    let prefixLen = firstString.lastIndexOf("/");

    if (prefixLen === -1) {
      return 0;
    }

    const len = strings.length;
    for (let i = 1; i < len && prefixLen !== 0; ++i) {
      const filename = strings[i];
      const len = min(prefixLen, filename.length);
      prefixLen = 0;
      while (prefixLen < len && filename[prefixLen] === firstString[prefixLen]) {
        ++prefixLen;
      }
    }

    const i = firstString.lastIndexOf("/", prefixLen);
    return (i !== -1) ? i + 1 : prefixLen;
  };

  let stringByChapters;
  let stringByImages;

  const initStrings = function() {
    strings = (options & SEARCH_BY_CHAPTER) ? stringByChapters : stringByImages;
    if (strings) {
      return;
    }

    let stringRefs = filenames;
    let stringRefsLen = nbFilename;
    if (options & SEARCH_BY_CHAPTER) {
      stringRefsLen = startIndexByChapters.length;
      stringRefs = new Array(stringRefsLen);
      for (let i = 0; i < stringRefsLen; ++i) {
        const chapIndex = startIndexByChapters[i];
        const filename = filenames[chapIndex];
        const index = filename.lastIndexOf("/");
        stringRefs[i] = (index === -1) ? filename : filename.substr(0, index);
      }
    }

    const prefixLen = searchCommonPrefixLength(stringRefs);

    // create string list reference
    strings = new Array(stringRefsLen);
    for (let i = 0; i < stringRefsLen; ++i) {
      strings[i] = stringRefs[i].substr(prefixLen);
    }

    if (options & SEARCH_BY_CHAPTER) {
      stringByChapters = strings;
    }
    else {
      stringByImages = strings;
    }
  };

  const updateStrings = function() {
    const oldStrings = strings;
    initStrings();
    if (oldStrings !== strings) {
      resetState();
      setActiveSearch(userActiveIndex());
      updateResults();
    }
  };

  const initImageStringsOfChapIndex = function(ichap) {
    const chap = chapterByIndexes[ichap];
    const images = chap.images;
    const length = images.length;
    strings = new Array(length);
    for (let i = 0; i < length; ++i) {
      const filename = images[i];
      const idx = filename.lastIndexOf("/");
      strings[i] = (idx === -1) ? filename : filename.substr(idx + 1);
    }
  };

  let initOptionsLock = false;
  const updateOptionsEvent = function(ev, firstOption, mask) {
    ev.preventDefault();
    ev.stopImmediatePropagation();

    if (initOptionsLock) {
      return;
    }

    const oldOptions = options;
    options &= ~mask;
    options |= firstOption << ev.target.selectedIndex;
    if ((oldOptions ^ options) & ~SEARCH_THEN_BY_MASK) {
      resetState();
      setActiveSearch(activeElement?.dataset.index | 0);
      updateResults();
    }
  };

  searchThenByElement.addEventListener("change", (ev) => {
    ev.preventDefault();
    ev.stopImmediatePropagation();
    options &= ~SEARCH_THEN_BY_MASK;
    options |= ev.target.checked ? SEARCH_THEN_BY_IMAGE : 0;
  });
  searchCaseSensitivityElement.addEventListener("change", (ev) => {
    updateOptionsEvent(ev, SEARCH_CASE_SENSITIVE, SEARCH_CASE_SENSITIVITY_MASK);
  });
  searchAccentSensitivityElement.addEventListener("change", (ev) => {
    updateOptionsEvent(ev, SEARCH_ACCENT_SENSITIVE, SEARCH_ACCENT_SENSITIVITY_MASK);
  });
  searchModeElement.addEventListener("change", (ev) => {
    updateOptionsEvent(ev, SEARCH_MODE_WORD, SEARCH_MODE_MASK);
  });
  searchByElement.addEventListener("change", function(ev) {
    ev.preventDefault();
    ev.stopImmediatePropagation();
    options &= ~SEARCH_BY_MASK;
    options |= SEARCH_BY_CHAPTER << ev.target.selectedIndex;
    updateStrings();
  });

  const updateForm = function(options) {
    const setSelectedIndex = function(elem, firstOption, mask) {
      let opt = options & mask;
      let i = 0;
      while (firstOption < opt) {
        opt >>= 1;
        ++i;
      }
      elem.selectedIndex = i;
    };

    initOptionsLock = true;
    searchThenByElement.checked = options & SEARCH_THEN_BY_IMAGE;
    setSelectedIndex(searchBy, SEARCH_BY_CHAPTER, SEARCH_BY_MASK);
    setSelectedIndex(searchCaseSensitivityElement, SEARCH_CASE_SENSITIVE, SEARCH_CASE_SENSITIVITY_MASK);
    setSelectedIndex(searchAccentSensitivityElement, SEARCH_ACCENT_SENSITIVE, SEARCH_ACCENT_SENSITIVITY_MASK);
    setSelectedIndex(searchModeElement, SEARCH_MODE_FUZZY, SEARCH_MODE_MASK);
    initOptionsLock = false;
  };

  let firstCall = true;

  const searcher = function(userOptions) {
    if (firstCall) {
      firstCall = false;
      options = userOptions;
      updateForm(options);
      initStrings();
      resetState();
      setActiveSearch(userActiveIndex());
    }
    else {
      options &= ~SEARCH_BY_IMAGE_IN_CHAP;
      savedIndex = null;
      updateStrings();
    }

    modal(isCloseEvent, () => {
      searcherElement.style.display = "none";
      input.blur();
    });
    searcherElement.style.display = "flex";
    input.focus();
  };

  searcher.reset = function() {
    stringByChapters = null;
    stringByImages = null;
    options = 0;
  };
  return searcher;
}());

// save and load
// @{
const savePosition = function() {
  localStorage.setItem("ifile", ifile);
  localStorage.setItem("modeName", modeToModeName(mode));
  localStorage.setItem("imageLimit", currentImageLimit);
};

const loadPosition = function() {
  const mode = modeNameToMode(localStorage.getItem("modeName"));
  if (!mode) {
    return
  }

  selectMode(mode, +localStorage.getItem("imageLimit"));

  // webtoon may take time to load images
  setTimeout(function() {
    mode.advance(localStorage.getItem("ifile") - ifile);
  }, 200);
};
// @}

const toggleMouseAssistance = (function() {
  const style = document.getElementById("mouseAssistance").style;
  let timerId = null;
  let enabled = false;

  const hideAssistance = function() {
    clearInterval(timerId);
    timerId = null;
    style.display = "none";
  };

  const showAssistance = function(e) {
    style.top = `${body.scrollTop}px`;
    style.display = "grid";
    clearInterval(timerId);
    timerId = setTimeout(hideAssistance, 200);
  };

  return function() {
    if (enabled) {
      enabled = false;
      window.removeEventListener("mousemove", showAssistance, true);
    }
    else {
      enabled = true;
      window.addEventListener("mousemove", showAssistance, true);
    }
  };
})();

const isInZone = function(e, zone) {
  const isTop = (e.clientY < window.innerHeight / 2);
  const isLeft = (e.clientX < window.innerWidth / 2);
  // top=1 bottom=2 left=4 right=8
  switch (zone) {
    case 1: return isTop;
    case 2: return !isTop;
    case 4: return isLeft;
    case 8: return !isLeft;
    case 5: return isTop && isLeft;
    case 9: return isTop && !isLeft;
    case 6: return !isTop && isLeft;
    case 10: return !isTop && !isLeft;
  }
};

const selectMode = function(newMode, imageLimit) {
  if (mode !== newMode || currentImageLimit !== imageLimit) {
    currentImageLimit = imageLimit;
    mode.stop();
    mode = newMode;
    mode.start(imageLimit);
    updateShortcuts(mode);
  }
};

const rgxClickName = /^click\d+$/
const createActions = function(shortcuts, actionsByKeys, actionsByClicks){
  actionsByKeys = actionsByKeys || {};
  actionsByClicks = actionsByClicks || [];

  for (const d of shortcuts) {
    let actionsByControls = actionsByKeys[d.key];
    if (!actionsByControls) {
      actionsByControls = {};
      actionsByKeys[d.key] = actionsByControls;
      if (rgxClickName.test(d.key)) {
        actionsByClicks[d.key.substr(5)] = actionsByControls
      }
    }
    actionsByControls[d.alt + (d.ctrl << 1) + (d.shift << 2) + (d.meta << 3) + (d.altgr << 4)] = d.action;
  }

  // if there is no conflict, assume assume that:
  // - Shift+Key = Key (ex. Shift+< = <)
  // - AltGr+Key = Key
  const res = [actionsByKeys, actionsByClicks];
  for (const actions of res) {
    for (const k in actions) {
      const actionsByControls = actions[k];
      for (const m in actionsByControls) {
        const withShift = m | 0b00100;
        const withAltgr = m | 0b10000;
        if (!actionsByControls[withShift]) {
          actionsByControls[withShift] = actionsByControls[m];
        }
        if (!actionsByControls[withAltgr]) {
          actionsByControls[withAltgr] = actionsByControls[m];
        }
        if (!actionsByControls[withShift | withAltgr]) {
          actionsByControls[withShift | withAltgr] = actionsByControls[m];
        }
      }
    }
  }

  return res;
};

// contains key and mouse actions
const [globalActionsByKeys, globalActionsByClicks] = createActions([{alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: ' ', action: function(){ downOrNext(bottomPixelDistance, body.clientHeight); }},
 {alt: 0, ctrl: 0, shift: 1, meta: 0, altgr: 0, key: ' ', action: function(){ upOrPrev(body.clientHeight); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'z', action: function(){ mode.advance(-5); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'x', action: function(){ mode.advance(5); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'a', action: function(){ mode.advance(-12); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 's', action: function(){ mode.advance(12); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'q', action: function(){ mode.advance(-30); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'w', action: function(){ mode.advance(30); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'e', action: function(){ mode.advance(-100); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'r', action: function(){ mode.advance(100); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'ArrowLeft', action: function(){ mode.advance(-1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'ArrowRight', action: function(){ mode.advance(1); }},
 {alt: 0, ctrl: 1, shift: 0, meta: 0, altgr: 0, key: 'ArrowLeft', action: function(){ mode.advance(-5); }},
 {alt: 0, ctrl: 1, shift: 0, meta: 0, altgr: 0, key: 'ArrowRight', action: function(){ mode.advance(5); }},
 {alt: 0, ctrl: 1, shift: 0, meta: 0, altgr: 0, key: 'ArrowUp', action: function(){ mode.advance(12); }},
 {alt: 0, ctrl: 1, shift: 0, meta: 0, altgr: 0, key: 'ArrowDown', action: function(){ mode.advance(-12); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '<', action: function(){ mode.advanceChap(-1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '>', action: function(){ mode.advanceChap(1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '|', action: function(){ mode.advance(-1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'c', action: function(){ upOrPrev(body.clientHeight); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'v', action: function(){ mode.advance(-1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'b', action: function(){ upOrPrev(body.clientHeight); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '.', action: function(){ mode.advance(-1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '/', action: function(){ downOrNext(bottomPixelDistance, body.clientHeight); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'm', action: function(){ rotate(-90); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: ',', action: function(){ rotate(90); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'g', action: function(){ showGoto(); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '^', action: function(){ gotoImage(0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '$', action: function(){ gotoImage(-1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'h', action: function(){ selectMode(webtoonMode, 0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'j', action: function(){ selectMode(doublePageMode, 0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'k', action: function(){ selectMode(normalMode, 0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'l', action: function(){ selectMode(normalOrDoublePageMode, 0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'd', action: function(){ showImageInfo(); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'o', action: function(){ showImageInfo(); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 't', action: function(){ toggleAutoScroll(800); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'u', action: function(){ addAutoScrollInterval(-25); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'i', action: function(){ addAutoScrollInterval(25); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'y', action: function(){ openInNewTab(0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'Y', action: function(){ openInNewTab(1); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'click0', action: function(){ downOrNext(bottomPixelDistance, body.clientHeight); }},
 {alt: 0, ctrl: 0, shift: 1, meta: 0, altgr: 0, key: 'click0', action: function(){ upOrPrev(body.clientHeight); }},
 {alt: 0, ctrl: 1, shift: 0, meta: 0, altgr: 0, key: 'click0', action: function(){ mode.advanceChap(1); }},
 {alt: 0, ctrl: 1, shift: 1, meta: 0, altgr: 0, key: 'click0', action: function(){ mode.advanceChap(-1); }},
 {alt: 1, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'click0', action: function(){ openInNewTab(0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 1, key: 'click0', action: function(){ openInNewTab(0); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: '@', action: function(){ toggleMouseAssistance() }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'F1', action: function(){ showShorcuts(); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'F8', action: function(){ let options = SEARCH_BY_CHAPTER | SEARCH_THEN_BY_IMAGE | SEARCH_UPPERCASE_ONLY | SEARCH_ACCENT_ONLY | SEARCH_MODE_WORD;showSearcher(options); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'F10', action: function(){ showLoader(); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'F6', action: function(){ savePosition(); }},
 {alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: 'F7', action: function(){ loadPosition(); }},
]);

const createModActions = function(shortcuts) {
  const actionsByKeys = {};
  for (const d in globalActionsByKeys) {
    actionsByKeys[d] = Object.assign({}, globalActionsByKeys[d]);
  }
  return createActions(shortcuts, actionsByKeys, Array.from(globalActionsByClicks));
};

allMode.shortcuts = createModActions([{alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: ' ', action: function(){ downOrNext(bottomPixelDistance, body.clientHeight * (98 / 100)); }},
{alt: 0, ctrl: 0, shift: 1, meta: 0, altgr: 0, key: ' ', action: function(){ upOrPrev(body.clientHeight * (98 / 100)); }},
]);
webtoonMode.shortcuts = createModActions([{alt: 0, ctrl: 0, shift: 0, meta: 0, altgr: 0, key: ' ', action: function(){ downOrNext(bottomPixelDistance, body.clientHeight * (98 / 100)); }},
{alt: 0, ctrl: 0, shift: 1, meta: 0, altgr: 0, key: ' ', action: function(){ upOrPrev(body.clientHeight * (98 / 100)); }},
]);


let actionsByKeys = globalActionsByKeys;
let actionsByClicks = globalActionsByClicks;
let actionsForPrimaryClick = actionsByClicks[0];

const eventMask = function(e) {
  return e.altKey
      + (e.ctrlKey << 1)
      + (e.shiftKey << 2)
      + (e.metaKey << 3)
      + (e.getModifierState("AltGraph") << 4)
      ;
};

const keydownEvent = function(e) {
  const actions = actionsByKeys[e.key] || actionsByKeys[e.key.toLowerCase()];
  if (actions) {
    const action = actions[eventMask(e)];
    if (action) {
      e.preventDefault();
      e.stopImmediatePropagation();
      action();
      return false;
    }
  }
  return true;
};

const clickEvent = function(e) {
  const action = actionsForPrimaryClick[eventMask(e)];
  if (action) {
    e.preventDefault();
    e.stopImmediatePropagation();
    action();
    return false;
  }
  return true;
};

const auxClickEvent = function(e) {
  let actions = actionsByClicks[e.button];
  if (actions) {
    const action = actions[e.altKey + (e.ctrlKey << 1) + (e.shiftKey << 2) + (e.metaKey << 3)];
    if (action) {
      e.preventDefault();
      e.stopImmediatePropagation();
      action(e);
      return false;
    }
    return true;
  }
};

function updateShortcuts(mode) {
  window.removeEventListener("click", clickEvent, true);
  window.removeEventListener("auxclick", auxClickEvent, true);

  actionsByKeys = mode.shortcuts ? mode.shortcuts[0] : globalActionsByKeys;
  actionsByClicks = mode.shortcuts ? mode.shortcuts[1] : globalActionsByClicks;

  if (0 in actionsByClicks) {
    actionsForPrimaryClick = actionsByClicks[0];
    window.addEventListener("click", clickEvent, true);
  }

  if (actionsByClicks.length > 1) {
    window.addEventListener("auxclick", auxClickEvent, true);
  }
}

function enableShortcuts() {
  window.addEventListener("keydown", keydownEvent, true);
  updateShortcuts(mode);
}

function disableShortcuts() {
  window.removeEventListener("click", clickEvent, true);
  window.removeEventListener("auxclick", auxClickEvent, true);
  window.removeEventListener("keydown", keydownEvent, true);
}

function initFilenames(fileNameList, fileByFileName) {
  fileByFilename = fileByFileName;
  filenames = fileNameList;
  nbFilename = filenames.length;
  chapterByIndexes = new Array(nbFilename);
  startIndexByChapters = [];
  showSearcher.reset();

  let filename = filenames[0];

  if (!filename) {
    mode.start();
    return;
  }

  let images = [filename];
  let seppos = filename.lastIndexOf("/");
  let subs = filename.substring(0, seppos);
  let startIndex = 0;
  let chap = {startIndex, images, ichap: 0};
  let seppos2;
  chapterByIndexes[0] = chap;
  startIndexByChapters.push(startIndex);
  for (let i = 1; i < nbFilename; ++i) {
    filename = filenames[i];
    seppos2 = filename.lastIndexOf("/");
    if (seppos2 === seppos && filename.startsWith(subs)) {
      images.push(filename);
    }
    else {
      seppos = seppos2;
      startIndex += images.length;
      images = [filename];
      chap = {startIndex, images, ichap: startIndexByChapters.length};
      subs = filename.substring(0, seppos);
      startIndexByChapters.push(startIndex);
    }

    chapterByIndexes[i] = chap;
  }

  mode.start(currentImageLimit);
}

enableShortcuts();

initFilenames(defaultFileNameList);

for (const d of [

]) {
  if (d.delay)
    setTimeout(d.action, d.delay);
  else
    d.action();
}




showLoader();

</script>
</body>
</html>
